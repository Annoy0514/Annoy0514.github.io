<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Annoy</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-18T12:48:19.759Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Annoy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【21/12/02】15_Java_Map</title>
    <link href="http://example.com/2021/12/18/15_Map/"/>
    <id>http://example.com/2021/12/18/15_Map/</id>
    <published>2021-12-18T12:46:49.109Z</published>
    <updated>2021-12-18T12:48:19.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map&lt;K,V&gt;：将键映射到值。</p><p><strong>特点：</strong></p><ol><li>键唯一。</li><li>键和值一一对应。一个键对应一个值。</li><li>靠键维护他们的关系。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.util.Map&lt;k,v&gt;集合</span></span><br><span class="line"><span class="comment">*   Map集合的特点:</span></span><br><span class="line"><span class="comment">*       1. Map集合是一个双列集合，一个元素包含两个值(一个key,一个value)</span></span><br><span class="line"><span class="comment">*       2. Map集合中的元素，key和value的数据类型可以是相同，也可以是不同。</span></span><br><span class="line"><span class="comment">*       3. Map集合中的元素，key不允许重复，value是可以重复的。</span></span><br><span class="line"><span class="comment">*       4. Map集合中的元素，key和value是一一对应的。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h4><p>(1) 第一种方式，通过键找值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Map集合的第一种遍历的方式：通过键找值的方式。</span></span><br><span class="line"><span class="comment">*   Map集合中的方法：</span></span><br><span class="line"><span class="comment">*       Set&lt;K&gt; keySet() 返回此映射中包含的键的Set视图。</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1. 使用Map集合中的方法keySet(),把Map集合所有的key取出来，存储到一个Set集合中。</span></span><br><span class="line"><span class="comment">*       2. 遍历set集合，获取Map集合中的每一个key。</span></span><br><span class="line"><span class="comment">*       3. 通过Map集合中的方法get(key),通过key找到value。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p>(2) 第二种方式，通过Entry对象，查找键和值。</p><p><img src="G:\Typora\img_dataset\1638366507464.png" alt="1638366507464"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Map.Entry&lt;K,V&gt;:在Map接口中有一个内部接口Entry</span></span><br><span class="line"><span class="comment">*   作用: 当Map集合一创建，就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值的映射关系)。</span></span><br><span class="line"><span class="comment">*   Map集合遍历的第二种方式：使用Entry对象遍历。</span></span><br><span class="line"><span class="comment">*   Map集合中的方法：</span></span><br><span class="line"><span class="comment">*       Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="HashMap-lt-K-V-gt-implement-Map-lt-k-v-gt"><a href="#HashMap-lt-K-V-gt-implement-Map-lt-k-v-gt" class="headerlink" title="HashMap&lt;K,V&gt; implement Map&lt;k,v&gt;"></a>HashMap&lt;K,V&gt; implement Map&lt;k,v&gt;</h4><p>特点：</p><ol><li><p>底层是哈希表，查询速度非常快。</p><p>JDK1.8之前：数组+单向链表。</p><p>JDK1.8之后：数组+单向链表/红黑树：提高查询的速度。</p></li><li><p>一个无序的集合。存储元素和取出元素的顺序有可能不一致。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo03_Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">*   Map集合保证key是唯一的：</span></span><br><span class="line"><span class="comment">*       作为key的元素，必须重写hashCode方法和equals方法，保证key唯一。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04HashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用keySet和增强for遍历集合</span></span><br><span class="line">        show00();</span><br><span class="line">        <span class="comment">// 使用entrySet和增强for循环遍历Map集合</span></span><br><span class="line"><span class="comment">//        show01();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show00</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashMap集合</span></span><br><span class="line">        HashMap&lt;String,Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 往集合添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;英国&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;俄罗斯&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;普京&quot;</span>,<span class="number">30</span>));</span><br><span class="line">        map.put(<span class="string">&quot;精灵国&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;秦国&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;秦始皇&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        <span class="comment">// 使用keySet和增强for遍历集合</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            Person value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   HashMap存储自定义类型的键值。</span></span><br><span class="line"><span class="comment">     *   Key:Person类型</span></span><br><span class="line"><span class="comment">     *       Person类型就必须重写hashCode方法和equals方法，保证key唯一。</span></span><br><span class="line"><span class="comment">     *   Value:String类型</span></span><br><span class="line"><span class="comment">     *       可以重复。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashMap集合</span></span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 往集合添加元素</span></span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>),<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;普京&quot;</span>,<span class="number">30</span>),<span class="string">&quot;俄罗斯&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>),<span class="string">&quot;精灵国&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;秦始皇&quot;</span>,<span class="number">17</span>),<span class="string">&quot;秦国&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用entrySet和增强for循环遍历Map集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Person,String&gt; entry:set) &#123;</span><br><span class="line">            Person key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap-lt-K-V-gt-extends-HashMap-lt-K-V-gt-集合"><a href="#LinkedHashMap-lt-K-V-gt-extends-HashMap-lt-K-V-gt-集合" class="headerlink" title="LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;集合"></a>LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;集合</h4><p>特点：</p><ol><li>底层是哈希表+链表（保证了迭代的顺序）</li><li>是一个有序的集合，存储元素与取出元素的顺序是一致的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo03_Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Map接口的哈希表和链表的实现，具有可预知的迭代顺序。</span></span><br><span class="line"><span class="comment">*   底层原理：</span></span><br><span class="line"><span class="comment">*       哈希表+链表（记录链表的顺序）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05LinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用普通的HashMap</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(<span class="string">&quot;__________________________&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用LinkedHashMap,保证顺序</span></span><br><span class="line">        LinkedHashMap&lt;String,String&gt; map1 = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;a=d, b=b, c=c&#125;</span><br><span class="line">__________________________</span><br><span class="line">&#123;a=d, c=c, b=b&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ol><li><p>此类实现一个哈希表，该哈希表将键映射到相应的值，任何<strong>非null对象</strong>都可以用作键或者值。</p></li><li><p>被HashMap取代了。</p></li><li><p>Hashtable的Properties依旧使用。常用于IO流操作。</p></li></ol><h3 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h3><p>List接口、Set接口、Map接口：增加一个静态的方法of,可以给集合一次性添加多个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">list&lt;E&gt; <span class="title">of</span> <span class="params">(E... elements)</span></span>;</span><br></pre></td></tr></table></figure><p>使用前提：</p><ol><li>当集合中存储的元素的个数已经确定了，不在改变时使用。</li></ol><p>注意：</p><ol><li>of方法只适用于List接口，Set接口，Map接口，不适用于接口的实现类。</li><li>of方法的返回值是一个不可改变的集合，集合<strong>不再使用add，put方法</strong>添加元素，会抛出异常。</li><li>Set接口和Map接口在调用of方法的时候，<strong>不能有重复的元素</strong>，否则会抛出异常。</li></ol>]]></content>
    
    
    <summary type="html">Java中Map接口知识点。(HashMap,LinkedHashMap,Hashtable)</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/01】14_Java_可变参数</title>
    <link href="http://example.com/2021/12/18/14_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>http://example.com/2021/12/18/14_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</id>
    <published>2021-12-18T12:45:23.085Z</published>
    <updated>2021-12-18T12:51:50.138Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   使用前提：当方法的参数列表数据类型已经确定，参数的个数不能确定，就可以使用可变参数。</span></span><br><span class="line"><span class="comment">*   使用格式：</span></span><br><span class="line"><span class="comment">*           修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;</span></span><br><span class="line"><span class="comment">*   可变参数的原理：</span></span><br><span class="line"><span class="comment">*           可变参数底层就是一个数组，根据传递参数的个数不同，会创建不同长度的数组，来存储这些参数。</span></span><br><span class="line"><span class="comment">*           传递的参数的个数，可以是0，1，2...多个</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01VarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个累加变量，记录求和。</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>一个方法的参数列表，只能有一个可变参数。</li><li>如果方法的参数有多个，那么可变参数必须放在参数列表的末尾。</li></ol><hr>]]></content>
    
    
    <summary type="html">Java中可变参数知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/01】13_Java_List知识点</title>
    <link href="http://example.com/2021/12/18/13_List/"/>
    <id>http://example.com/2021/12/18/13_List/</id>
    <published>2021-12-18T12:39:17.826Z</published>
    <updated>2021-12-18T12:45:07.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>List接口的特点：</p><ol><li>有序的集合，存储元素与取出元素的顺序是一致的。</li><li>有索引，包含了一些带索引的方法。</li><li>允许存储重复的元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.list接口 extends Collection接口;</span><br></pre></td></tr></table></figure><h3 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ArrayList;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>ArrayList集合数据存储的结构是<strong>数组结构</strong>。元素增删慢，查找快。</li><li>由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</li></ol><h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>底层是一个链表结构，查询慢，增删快。</li><li>里面包含了大量操作首尾元素的方法。</li><li>使用LinkedList集合特有的方法，<strong>不能使用多态</strong>。</li></ol><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>继承Collection类。</p><p>特点：</p><ol><li>不包含重复元素。</li><li>没有索引。</li></ol><h4 id="HashSet集合-implements-Set接口"><a href="#HashSet集合-implements-Set接口" class="headerlink" title="HashSet集合 implements Set接口"></a>HashSet集合 implements Set接口</h4><p>特点：</p><ol><li>不允许存储重复的元素。</li><li>没有索引，没有带索引的方法。不能使用for循环遍历。</li><li>无序的集合，存储元素和取出元素的顺序不一致。</li><li>底层是一个哈希表结构(查询速度非常快)。</li></ol><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>一个十进制的整数，由系统随机给出。（对象的地址，是一个逻辑地址，不是实际的存储的物理地址。）</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>HashSet集合存储的数据的结构。(哈希表)</p><p>JDK1.8之前：哈希表= 数组 + 链表。</p><p>JDK1.8之后：哈希表 = 数组 + 链表；哈希表 = 数组 + 红黑树(提升查询的速度)。</p><p><strong>哈希表的特点：速度快。</strong></p><img src="/2021/12/18/13_List/1638329190319.png" class="" width="1638329190319"><p><strong>使用HashSet存储自定义类型的元素。</strong></p><p>必须重写hashCode()方法和equals方法。</p><h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><p>继承自 HashSet集合。</p><p>特点：</p><ol><li>底层是一个<strong>哈希表</strong>(数组+链表/红黑树)+<strong>链表</strong>：多一条链表（记录元素的存储位置），保证元素有序。</li><li>不允许重复。</li></ol>]]></content>
    
    
    <summary type="html">Java中List集合相关内容。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/30】12_Java_数据结构基础知识点(一)</title>
    <link href="http://example.com/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-12-18T12:31:04.494Z</published>
    <updated>2021-12-18T12:34:16.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h3><p>特点：先进后出。</p><p>存储元素到集合：入栈、压栈。</p><p>取出集合中的元素：出栈。</p><img src="/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1638262801017.png" class="" width="1638262801017"><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h3><p>特点：先进先出。</p><p>入口和出口在集合的两侧。</p><img src="/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1638263082522.png" class="" width="1638263082522"><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h3><p>特点：查询快，增删慢。</p><p>查询快：数组的地址是连续的，根据数组的首地址可以找到数组，通过数组的索引可以快速查找某一个元素。</p><p>增删慢：数组的长度是固定的，要增加或删除一个元素，必须创建一个新数组，把源数组的数据复制过来。</p><h3 id="4-链表"><a href="#4-链表" class="headerlink" title="4 链表"></a>4 链表</h3><p>特点：查询慢，增删快。</p><p>查询慢：链表中的地址不是连续的，每次查询元素，都必须从头开始查询。</p><p>增删快：链表结构，增加删除一个元素，对链表的整体结构没有影响，所以增删快。</p><img src="/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1638263702263.png" class="" width="1638263702263"><p>单向链表：链表中只有一条链子，不能保证元素的顺序（存储元素和取出元素的顺序有可能不一致）</p><p>双向链表：链表中有两条链，一条专门记录元素的顺序，是一个有序的集合。</p><img src="/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1638264032742.png" class="" width="1638264032742"><h3 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5 红黑树"></a>5 红黑树</h3><p>二叉树：分支不能超过两个。</p><p>排序树：在二叉树的基础上，元素有大小顺序。左子树小，右子树大。</p><p>平衡树：左子树与右子树相等。</p><p><strong>红黑树：</strong>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数与最小次数不能超过2倍。</p><img src="/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1638326408272.png" class="" title="label">]]></content>
    
    
    <summary type="html">数据结构中栈、队列、数组、链表、红黑树。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/30】11_Java_泛型</title>
    <link href="http://example.com/2021/12/17/11_%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2021/12/17/11_%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-12-17T14:08:21.494Z</published>
    <updated>2021-12-17T14:12:37.132Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1 泛型"></a>1 泛型</h3><p>一种不确定的数据类型，不知道使用什么数据类型的时候可以使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中&lt;E&gt;代表泛型，不知道使用什么数据类型。</span></span><br></pre></td></tr></table></figure><p>创建对象的时候，就会确定泛型的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会把数据类型当作参数传递，下列例子就是将String赋值给泛型E。</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2 Student类型的数据</span></span><br><span class="line">ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="2-创建集合对象，使用泛型"><a href="#2-创建集合对象，使用泛型" class="headerlink" title="2 创建集合对象，使用泛型"></a>2 创建集合对象，使用泛型</h3><p>好处：</p><ol><li>避免了类型转换的麻烦，存储的什么类型，取出的就是什么类型。</li><li>把运行期异常（代码运行之后抛出的异常），提升到编译器（写代码报错）。</li></ol><p>弊端：</p><ol><li>泛型是什么类型，就只能存储什么类型的数据。</li></ol><h4 id="定义含有泛型的类"><a href="#定义含有泛型的类" class="headerlink" title="定义含有泛型的类"></a>定义含有泛型的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;泛型&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line">GenericClass&lt;Integer&gt; gc1 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">gc1.setName(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Integer name = gc1.getName();</span><br><span class="line">System.out.println(name); </span><br></pre></td></tr></table></figure><h4 id="定义含有泛型的方法"><a href="#定义含有泛型的方法" class="headerlink" title="定义含有泛型的方法"></a>定义含有泛型的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式</span></span><br><span class="line">修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>含有泛型的方法，在调用的时候确定泛型的数据类型。</p><p>传递什么类型的数据，泛型就是什么类型。</p><h4 id="定义含有泛型的接口"><a href="#定义含有泛型的接口" class="headerlink" title="定义含有泛型的接口"></a>定义含有泛型的接口</h4><p>接口使用什么泛型，实现类就使用什么泛型，类跟着接口走。</p><p>相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">publuc <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-泛型通配符"><a href="#3-泛型通配符" class="headerlink" title="3 泛型通配符"></a>3 泛型通配符</h3><p>当使用泛型类或接口的时候，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用通配符后，只能使用Object类中的共性方法，集合中元素自身的方法不可用。</p><p>泛型的通配符：不知道使用什么类型来接受的时候，此时可以使用?,?表示未知通配符。</p><p>此时只能接收数据，不可以往该集合中存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">泛型的通配符：</span></span><br><span class="line"><span class="comment">？：代表任意的数据类型</span></span><br><span class="line"><span class="comment">使用方式：</span></span><br><span class="line"><span class="comment">不能创建对象使用。</span></span><br><span class="line"><span class="comment">只能作为方法的参数使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="泛型通配符的高阶使用"><a href="#泛型通配符的高阶使用" class="headerlink" title="泛型通配符的高阶使用"></a>泛型通配符的高阶使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">泛型的上限限定：? extends E 代表使用的泛型只能是E类型的子类/本身</span></span><br><span class="line"><span class="comment">泛型的下限限定：? super E 代表使用的泛型只能是E类型的父类/本身</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中泛型的知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】10_Java_Collection集合</title>
    <link href="http://example.com/2021/12/17/10_Collection/"/>
    <id>http://example.com/2021/12/17/10_Collection/</id>
    <published>2021-12-17T14:05:58.300Z</published>
    <updated>2021-12-18T12:30:36.892Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h2><p>Collection内存储<strong>对象的集合</strong>。</p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><img src="/2021/12/17/10_Collection/1638240360794.png" class="" title="img"><h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>用于迭代访问Collection中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 获取集合对应的迭代器，用来遍历集合中的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 判断集合中还有没有下一个元素，有就返回true,没有就返回false</span></span><br><span class="line">next(); <span class="comment">// 返回迭代的下一个元素</span></span><br></pre></td></tr></table></figure><p>Iterator迭代器是一个接口，无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方法。</p><p>Collection接口中有一个方法，叫iterator()，这个方法返回迭代器的实现类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 返回在此collection的元素上进行迭代的迭代器。</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的使用【重点】"><a href="#迭代器的使用【重点】" class="headerlink" title="迭代器的使用【重点】"></a>迭代器的使用【重点】</h4><ol><li>使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收(多态)</li><li>使用Iterator接口中的方法hasNext判断还有没有下一个元素</li><li>使用Iterator接口中的方法next取出集合中的下一个元素</li></ol><h2 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h2><hr>]]></content>
    
    
    <summary type="html">Java中Collection集合的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】9_Java_包装类</title>
    <link href="http://example.com/2021/12/17/9_%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://example.com/2021/12/17/9_%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2021-12-17T14:03:39.288Z</published>
    <updated>2021-12-17T14:05:40.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>基本数据类型,使用起来非常方便,但是没有对应的方法来操作这些基本类型的数据。</p><p>可以使用一个类,把基本类型的数据装起来,在类中定义一些方法,这个类叫做包装类。</p><p>我们可以使用类中的方法来操作这些基本类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装箱：把基本类型的数据，包装到包装类中（基本数据类型-&gt;包装类）</span></span><br><span class="line"><span class="comment">* 构造方法：</span></span><br><span class="line"><span class="comment">*   Integer(int value) 构造一个新的Integer对象，代表指定的int值。</span></span><br><span class="line"><span class="comment">*   Integer(String s) 构造一个新分配的Integer对象，表示String参数所指示的int值。</span></span><br><span class="line"><span class="comment">*   传递的字符串必须是基本类型的字符串，否则会抛出异常。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(in1);</span><br><span class="line"></span><br><span class="line">Integer in2 = <span class="keyword">new</span> Integer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(in2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 拆箱：在包装类中取出基本类型的数据。（包装类-&gt;基本类型的数据）</span></span><br><span class="line"><span class="comment">* 成员方法：</span></span><br><span class="line"><span class="comment">*   int intValue()以int类型返回该Integer的值。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="基本类型与字符串类型的相互转换"><a href="#基本类型与字符串类型的相互转换" class="headerlink" title="基本类型与字符串类型的相互转换"></a>基本类型与字符串类型的相互转换</h4><p><strong>(1) 基本类型到字符串类型</strong></p><ol><li>基本类型的值+“ ” 【最简单的方法】。</li><li>包装类的静态方法toString(参数)，不是Object中的toString()重载。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 返回一个表示指定整数的String对象。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>String类的静态方法valueOf(参数)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 返回int参数的字符串表示形式。</span></span><br></pre></td></tr></table></figure><p><strong>(2) 字符串到基本类型</strong></p><p>使用包装类的静态方法parseXXX(“字符串”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="comment">// Double类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseDouble</span><span class="params">(String s)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中包装类的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】8_Java_StringBuilder类</title>
    <link href="http://example.com/2021/12/17/8_StringBuilder/"/>
    <id>http://example.com/2021/12/17/8_StringBuilder/</id>
    <published>2021-12-17T14:02:26.464Z</published>
    <updated>2021-12-17T14:03:28.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="StringBuilder类【字符串缓冲区】"><a href="#StringBuilder类【字符串缓冲区】" class="headerlink" title="StringBuilder类【字符串缓冲区】"></a>StringBuilder类【字符串缓冲区】</h3><p>可以解决字符串拼接问题。</p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ol><li>字符串是常量，被定义后不能被改变。</li><li>字符串的底层是一个被final修饰的数组，不能改变，是一个常量。</li></ol><p>使用String进行字符串的相加，内存会有多个字符串，占用空间较多，效率低下。</p><h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><ol><li><p>是一个字符串缓冲区，提高字符串操作的效率。</p></li><li><p>底层是一个数组，但是<font color=red>没有被final修饰</font>，可以改变。</p></li><li><p>在内存中始终是一个数组，占用空间少，效率高。超出了StringBuilder的容量，会自动扩容。</p></li></ol><p><strong>1 构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 构造一个不带字符的字符串生成器，其容量为16个字符。</span></span><br><span class="line">StringBuilder bu1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 2 构造一个字符串生成器，并初始化为指定的字符串内容。</span></span><br><span class="line">StringBuilder(String str);</span><br></pre></td></tr></table></figure><p><strong>2 成员方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 添加任意类型数据的字符串形式，并返回当前对象自身。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="comment">// 2 将当前的StringBuilder对象转换为String对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中StringBuilder的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】7_Java_System类</title>
    <link href="http://example.com/2021/12/17/7_System%E7%B1%BB/"/>
    <id>http://example.com/2021/12/17/7_System%E7%B1%BB/</id>
    <published>2021-12-17T14:00:30.552Z</published>
    <updated>2021-12-17T14:01:36.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.System;</span><br></pre></td></tr></table></figure><p>提供了大量得静态方法，可以获取与系统相关的信息或者系统级操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 将数组中指定的数据拷贝到另外一个数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">src-源数组</span></span><br><span class="line"><span class="comment"> srcPos - 源数组中的起始位置（索引）</span></span><br><span class="line"><span class="comment"> dest - 目标数组</span></span><br><span class="line"><span class="comment"> destPos - 目标数组的起始位置</span></span><br><span class="line"><span class="comment"> length - 复制的数据元素的数量</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中System类的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/28】5_Java_接口与多态</title>
    <link href="http://example.com/2021/12/17/5_%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>http://example.com/2021/12/17/5_%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/</id>
    <published>2021-12-17T13:48:29.699Z</published>
    <updated>2021-12-17T14:02:12.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口(Interface)"></a>接口(Interface)</h3><p>一种公共的规范标准。</p><p>一种引用数据类型。最重要的内容就是：抽象方法。</p><h4 id="定义一个接口："><a href="#定义一个接口：" class="headerlink" title="定义一个接口："></a>定义一个接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 接口内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译生成的字节码文件 .java-&gt;.class</span></span><br></pre></td></tr></table></figure><h4 id="接口中定义抽象方法："><a href="#接口中定义抽象方法：" class="headerlink" title="接口中定义抽象方法："></a>接口中定义抽象方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(参数列表);</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>接口中的抽象方法，修饰符是两个固定的关键字:public abstract</li><li>两个关键字修饰符可以省略。</li><li>方法的三要素可以随意定义。</li></ol><h4 id="接口的使用："><a href="#接口的使用：" class="headerlink" title="接口的使用："></a>接口的使用：</h4><ol><li>接口不能直接使用，需要有一个”实现类“来”实现”该接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>接口的实现必须覆盖重写(实现)接口中的<strong>所有的抽象方法</strong>。</li></ol><p>实现：去掉abstract关键字，加上方法体大括号。</p><ol start="3"><li>创建实现类的对象，进行使用。</li></ol><p><strong>注意事项</strong>：</p><p>如果实现类没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类。</p><h4 id="接口的默认方法："><a href="#接口的默认方法：" class="headerlink" title="接口的默认方法："></a>接口的默认方法：</h4><p>接口的默认方法，用来解决接口升级的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接口的默认方法，可以通过接口实现类对象，直接调用。</li><li>接口的默认方法，也可以被接口实现类进行覆盖重写。</li></ol><h4 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h4><p>从Java 8开始，接口当中允许定义静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line"><span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：不能通过接口实现类的对象来调用接口当中的静态方法。</p><p><strong>正确用法</strong>：通过接口名称，直接调用其中的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        MyInterfaceStaticImpl impl = <span class="keyword">new</span> MyInterfaceStaticImpl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 错误写法</span></span><br><span class="line">        impl.methodStatic();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正确写法</span></span><br><span class="line">        MyInterfaceStatic.methodStatic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口的成员变量"><a href="#接口的成员变量" class="headerlink" title="接口的成员变量"></a>接口的成员变量</h4><p>接口中也是可以定义”成员变量“，但是必须使用public static final 三个关键字进行修饰。</p><p>从效果上来看，就是接口的【常量】。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 常量名称 = 数据值；</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>一旦使用final关键词进行修饰，说明不可改变。</li><li>接口中的常量，可以省略public static final.</li><li>接口中的常量，必须赋值，不能不赋值。</li><li>接口中常量的名称，使用完全大写的字母，并且用下划线进行分隔。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceConst</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一旦赋值，不可改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF_MY_CLASS = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用接口的注意事项"><a href="#使用接口的注意事项" class="headerlink" title="使用接口的注意事项"></a>使用接口的注意事项</h4><ol><li><p>接口没有静态代码块和构造方法。</p></li><li><p>一个类的直接父类是唯一的，一个类可以同时实现多个接口。</p></li><li><p>如果实现类所实现的多个接口当中，存在<strong>重复的抽象方法</strong>，那么只需要覆盖重写一次即可。</p></li><li><p>如果实现类没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类。</p></li><li><p>如果实现类实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。</p></li><li><p>一个类如果直接父类中的方法和接口中的默认方法产生了冲突，优先用父类中的方法。【继承优先级高于接口】</p></li></ol><h4 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h4><ol><li>类与类之间是单继承的，直接父类只有一个。</li><li>类与接口之间是多实现的，一个类可以实现多个接口。</li><li>接口与接口之间是多继承的。</li></ol><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>extends继承或者implements实现，是多态性的前提。</p><p>代码中体现多态性：<strong>父类引用指向子类对象。</strong></p><h4 id="访问成员变量的方法："><a href="#访问成员变量的方法：" class="headerlink" title="访问成员变量的方法："></a>访问成员变量的方法：</h4><ol><li>直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。</li><li>间接通过成员方法访问成员变量：方法属于谁，优先用谁，没有则向上找。</li></ol><h4 id="多态中成员方法的使用："><a href="#多态中成员方法的使用：" class="headerlink" title="多态中成员方法的使用："></a>多态中成员方法的使用：</h4><ol><li>看new的是谁，优先用谁，没有就向上找。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01MultiMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu obj = <span class="keyword">new</span> Zi(); <span class="comment">// 多态</span></span><br><span class="line">        </span><br><span class="line">        obj.method(); <span class="comment">// 父子都有，优先用子</span></span><br><span class="line">        obj.method(); <span class="comment">// 子类没有，父类有，向上找到父类</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// *编译看左边，运行看右边。*</span></span><br><span class="line">        <span class="comment">// 编译看左边，左边是父类，没有methondZi方法，所以编译报错。</span></span><br><span class="line">        obj.methodZi(); <span class="comment">// 错误！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>成员变量：编译看左边，运行也看左边。</p><p>成员方法：编译看左边，运行看右边。</p><hr><h3 id="对象的转型"><a href="#对象的转型" class="headerlink" title="对象的转型"></a>对象的转型</h3><ol><li>对象的向上转型，就是 <strong>多态</strong> 写法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名称 对象名 = <span class="keyword">new</span> 子类名称();</span><br></pre></td></tr></table></figure><p>含义：右侧创建一个子类对象，把它当作父类看待。</p><p>注意事项： 向上转型一定是安全的。从小范围转到大范围。</p><ol start="2"><li>对象的向下转型，是一个 <strong>还原</strong> 动作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类名称 对象名 = (子类名称) 父类对象;</span><br></pre></td></tr></table></figure><p>含义：将父类对象还原成原来的子类对象。</p><p>注意事项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat(); <span class="comment">// 本来就是猫，向上转型成动物。</span></span><br><span class="line">Cat cat = (Cat) animal; <span class="comment">// 本来就是猫，被当作动物了，现在进行还原。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 1. 必须保证对象本来创建的时候就是猫，才能向下转型成猫。</span></span><br><span class="line"><span class="comment">// 2. 如果对象创建的时候不是猫，现在非要向下转型成为猫，就会报错。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>判断父类引用对象，本来是什么子类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对象 <span class="keyword">instanceof</span> 类名称;</span><br><span class="line"><span class="comment">// 得到的结果是一个boolean值</span></span><br><span class="line"><span class="comment">// 判断前面的对象能不能当作后面的实例。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断这个对象是否是Dog</span></span><br><span class="line"><span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    Dog dog = (Dog) animal;</span><br><span class="line">    <span class="comment">// 调用dog方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>代表不可改变的。</p><p>常见用法：</p><ol><li><p>修饰类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名称 </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代表这个类不能有任何的子类。</span></span><br></pre></td></tr></table></figure><p>注意：如果一个类是final的，其中所有的成员方法都无法进行覆盖重写。</p></li><li><p>修饰方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名称(参数列表) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// final关键字修饰一个方法的时候，这个方法就是最终的方法，不能被覆盖重写。</span></span><br></pre></td></tr></table></figure><p>注意：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。</p></li><li><p>修饰局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。</span></span><br><span class="line"><span class="comment">// “一次赋值，终生不变。”</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>对于基本类型，不可变代表变量当中的 <strong>数据</strong> 不可变。</li><li>对于引用类型，不可变代表变量中的 <strong>地址值</strong> 不可变。</li></ol></li><li><p>修饰成员变量。</p><p>如果使用final关键字修饰，那么这个变量也照样是不可变的。</p><ol><li><p>对于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。</p></li><li><p>对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。</p></li><li><p>必须保证类当中所有重载的构造方法，都最终对final的成员变量进行赋值。</p></li></ol></li></ol><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类内部包含另一个类。</p><p><strong>分类</strong></p><ol><li><p>成员内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 内部类名称 </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：内用外，随意访问；外用内，需要<strong>内部类对象</strong>。</p><p><strong>使用成员内部类</strong>：</p><ol><li><p>间接使用: 在外部类的方法中，使用内部类；然后main只是调用外部类的方法。</p></li><li><p>直接使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称();</span><br><span class="line">外部类名称.内部类名称 对象名 = <span class="keyword">new</span> 外部类名称().new 内部类名称();</span><br></pre></td></tr></table></figure></li><li><p>内部类重名访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名称.<span class="keyword">this</span>.外部类成员变量名</span><br></pre></td></tr></table></figure></li></ol></li><li><p>局部内部类</p><p>如果一个类定义在一个方法内部，那么就是一个局部内部类。</p><p>局部：是由当前所属的方法可以使用它，出了这个方法就不能用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 外部类名称 </span>&#123;</span><br><span class="line">    修饰符 返回值类型 外部类方法名称(参数列表) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>定义一个类时的权限修饰符<ol><li>外部类：public default</li><li>成员内部类：public/protected/(default)/private</li><li>局部内部类：什么都不写</li></ol></li></ol><hr><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>如果接口的实现类只需要使用唯一的一次，那么这种情况下就可以省略该类的定义，而改为使用【匿名内部类】。</p><p><strong>匿名内部类的定义格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名 = <span class="keyword">new</span> 接口名称() &#123;</span><br><span class="line">    <span class="comment">// 覆盖重写所有的抽象方法</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1.new代表创建对象的动作</span></span><br><span class="line"><span class="comment">// 2.接口名称就是匿名内部类需要实现哪个接口</span></span><br><span class="line"><span class="comment">// &#123;...&#125;才是匿名内部类的内容</span></span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li><p>匿名内部类，在【创建对象】的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样，就需要使用单独定义的实现类。</p></li><li><p>匿名对象，在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象，调用多次方法，那么必须给对象起个名字。</p></li><li><p>匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】。</p></li></ol>]]></content>
    
    
    <summary type="html">Java接口与多态相关知识点总结。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】6_Java_日期与时间的类</title>
    <link href="http://example.com/2021/12/17/6_%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E7%B1%BB/"/>
    <id>http://example.com/2021/12/17/6_%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E7%B1%BB/</id>
    <published>2021-12-17T13:47:34.324Z</published>
    <updated>2021-12-17T13:59:01.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日期和时间类"><a href="#日期和时间类" class="headerlink" title="日期和时间类"></a>日期和时间类</h3><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date; <span class="comment">// 表示日期和时间的类</span></span><br><span class="line"><span class="comment">// 精确到毫秒，可以对时间和日期进行计算。</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(); <span class="comment">// 获取当前系统的时间</span></span><br></pre></td></tr></table></figure><h4 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h4><p>格式化：日期-&gt;文本；解析：文本-》日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">format</span><span class="params">(Date date)</span></span>;  <span class="comment">// 日期转文本</span></span><br><span class="line"><span class="function">Date <span class="title">parse</span><span class="params">(String source)</span></span>; <span class="comment">// 文本解析成日期</span></span><br></pre></td></tr></table></figure><p>使用DateFormat类中的方法format，把日期格式转化为文本。</p><p>使用步骤:</p><ol><li>创建SimpleDateFormat对象，构造方法中传递指定的模式。</li><li>调用SimpleDateFormat对象中的format，按照构造方法中指定的模式，把Date日期格式化为符合模式的字符串（文本）。</li></ol><h4 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="comment">// 是一个抽象类，提供了一些操作日历字段的方法。</span></span><br><span class="line"><span class="comment">// Calendar类无法直接创建对象使用，里面有一个静态的方法getInstance()获取Calendar对象。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中与日期时间相关的操作类。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/27】Java开发基础知识点(二)</title>
    <link href="http://example.com/2021/12/17/2_%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2021/12/17/2_%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-12-17T13:18:50.160Z</published>
    <updated>2021-12-17T13:35:07.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java知识点（二）"><a href="#Java知识点（二）" class="headerlink" title="Java知识点（二）"></a>Java知识点（二）</h1><p><strong>1 包装类型</strong></p><p> 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><hr><p><strong>2 缓存池：</strong></p><p>（1）new Integer(123)</p><p>每次都会<strong>新建一个对象</strong>。</p><p>（2）Integer.valueOf(123)</p><p>会<strong>使用缓存池中的对象</strong>，多次调用会取得同一个对象的引用。  </p><p>先<strong>判断值是否在缓存池中</strong>，如果在的话就直接返回缓存池的内容。</p><p> Java 8 中，Integer <strong>缓存池的大小</strong>默认为 -128~127 。</p><hr><p><strong>3  String：</strong></p><p>String被声明成<strong>final</strong>，因此它<strong>不可被继承</strong>。</p><p>内部<strong>使用char数组存储数据</strong>，该数组被声明成final，意味着value数组初始化之后就不能引用其他数组。并且String内部没有改变value数组的方法，可以保证String不可变。</p><p><strong>好处：</strong></p><p>​    (1) 可以用来缓存hash值</p><p>​        例如用String用作HashMap的key.</p><p>​    (2) String Pool</p><p>​        如果一个String对象已经被创建过了，就会从String Pool中取得引用。</p><p>​    (3)安全性</p><p>​        String经常作为参数，可以保证参数不变。</p><p>​    (4)线程安全</p><p>​        String的不变性可以在多个线程中安全地使用。</p><hr><p><strong>4 String【不可变】, StringBuffer and StringBuilder【可变】：</strong></p><p>(1)线程安全问题</p><p>String不可变【线程安全】</p><p>StringBuilder【不是线程安全的】</p><p>StringBuffer【线程安全，内部使用 <strong>synchronized</strong> 进行同步 】</p><hr><p><strong>5 String.intern()</strong></p><p> 使用 String.intern() 可以<strong>保证相同内容的字符串变量引用同一的内存对象</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。</span></span><br><span class="line"><span class="comment">// intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是采用 &quot;bbb&quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</span></span><br><span class="line">String s4 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">String s5 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><p><strong>6 参数传递</strong></p><p> Java 的参数是以值传递的形式传入方法中，而不是引用传递。 </p>]]></content>
    
    
    <summary type="html">包装、缓存池、Sting...</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/27】Java面向对象知识碎片</title>
    <link href="http://example.com/2021/12/17/1_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/12/17/1_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-12-17T13:02:40.239Z</published>
    <updated>2021-12-17T13:18:10.859Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>(1) 面向过程：实现功能的时候，要详细处理每一个细节。</p><p>(2) 面向对象：实现功能的时候，不关心具体的步骤，而是找一个具有该功能的人来帮我做事。</p><img src="/2021/12/17/1_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1637415427333.png" class="" title="img"><hr><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>将细节信息隐藏起来，对于外界不可见。</p><p>利用抽象数据类型将<strong>数据和基于数据的操作封装</strong>在一起，使其构成一个不可分割的独立实体。 </p><p>保留一些<strong>对外接口</strong>使之与外部发生联系。 可以通过对象对外提供的接口来访问该对象。 </p><p><strong>优点：</strong></p><ol><li>减小耦合</li><li>减轻维护的负担</li><li>有效地调节性能</li><li>提高软件可重用性</li><li>降低构建大型系统的风险</li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是多态的前提，没有继承就没有多态。</p><p>解决的主要问题：<strong>共性抽取</strong>。</p><img src="/2021/12/17/1_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1637979780869.png" class="" title="img"><p>继承的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类的格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 父类名称 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类的格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名称 <span class="keyword">extends</span> 父类名称 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父子类的继承关系中，创建子类对象，访问成员方法的规则：</p><p><strong>创建的对象是谁，就优先用谁，如果没有则向上找。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">// num: 局部变量，30</span></span><br><span class="line">        <span class="comment">// this.num: 成员变量，20</span></span><br><span class="line">        <span class="comment">// super.num: 父类的成员变量，10</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承应该遵循<strong>里氏替换原则</strong>，子类对象必须能够替换掉所有父类对象。</p><p><strong>重写(override)</strong></p><p>概念：在继承关系中，方法的名称一样，参数列表也一样。</p><p>重写(Override): 方法的名称一样，参数列表【也一样】。覆盖、覆写。</p><p>重载(Overload)：方法的名称一样，参数列表【不一样】。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测重写是否正确,一种检测手段。</span></span><br><span class="line"><span class="meta">@Override</span></span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li><p>保证父与子之间的方法名称相同，参数列表也相同。</p></li><li><p>子类方法的返回值必须【小于等于】父类方法的返回值范围。</p><p>java.lang.Object类是所有类的公共最高父类，java.lang.String是Object的子类。</p></li><li><p>子类方法的权限必须【大于等于】父类方法的权限修饰符。</p><p>public &gt; protected &gt; (default) &gt; private</p><p>(default)是留空不写。</p></li></ol><p><strong>设计原则</strong>：</p><p>对于已经使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中的共性内容，并且添加改动的新内容。</p><p><strong>构造方法：</strong></p><ol><li>子类构造方法中有一个默认隐含的super()调用，一定是先调用的父类构造，后执行的子类构造。</li><li>子类构造可以通过super关键字来调用父类重载构造。</li><li>super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li></ol><p><font color='red'>Java继承的特点</font></p><ol><li><p>Java语言是<strong>单继承</strong>的。</p><p>一个类的直接父类只能有唯一一个。</p></li><li><p>Java语言可以<strong>多级继承</strong>。</p><p>一个子类的父类，也可以有父类。</p></li><li><p>一个子类的直接父类是唯一的，但是一个父类可以拥有多个子类。</p></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p> 多态分为<strong>编译时多态</strong>【 方法的重载 】和<strong>运行时多态</strong>【 程序中定义的对象引用所指向的具体类型在运行期间才确定 。包括<strong>继承、重写、向上转型</strong>】。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li><strong>泛化关系（Generalization）</strong>：用来描述<strong>继承关系</strong>。</li></ul><p> <img src="https://pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png" alt="img"> </p><ul><li><strong>实现关系（Realization）</strong>：用来实现一个<strong>接口</strong>。</li></ul><p> <img src="https://pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png" alt="img"> </p><ul><li><strong>聚合关系（Aggregation）</strong>： 表示<strong>整体由部分组成</strong>，但是整体和部分<strong>不是强依赖</strong>的，整体不存在了部分还是会存在。 </li></ul><p> <img src="https://pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png" alt="img"> </p><ul><li><strong>组合关系（Composition）</strong>： 组合中整体和部分是<strong>强依赖</strong>的，整体不存在了部分也不存在了。 </li></ul><p> <img src="https://pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png" alt="img"> </p><ul><li><strong>关联关系（Association）</strong>：表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</li></ul><p> <img src="https://pdai.tech/_images/pics/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png" alt="img"> （1对多的关系）</p><ul><li><strong>依赖关系（Dependency）</strong></li></ul><p> 依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式: </p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><p> <img src="https://pdai.tech/_images/pics/LOun2W9134NxVugmbJPp15d4LalxC4O.png" alt="img"> </p><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>成员变量【属性】: 直接定义在类当中，在方法外面。</p><p>成员方法【行为】: 成员方法不要写static关键字。</p><p><strong>通常情况下，一个类不能直接使用，需要根据类创建一个对象，才能使用。</strong></p><ol><li>导包：指出需要使用的类，在什么位置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名称.类名称;</span><br><span class="line"><span class="comment">// 对于和当前类同属一个包的情况，可以省略导包语句不写。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建，格式:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称();</span><br><span class="line"><span class="comment">// Student stu = new Student();</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用，分两种情况：</p><p>(1) 使用成员变量:  对象名.成员变量名</p><p>(2) 使用成员方法: 对象名.成员方法名(参数)</p><p>(想用谁就用“对象名.谁”。)</p></li></ol><p>当一个对象作为参数，传递到方法当中时，实际上传递进去的是<strong>对象的地址值</strong>。</p><h4 id="局部变量与成员变量"><a href="#局部变量与成员变量" class="headerlink" title="局部变量与成员变量"></a>局部变量与成员变量</h4><ol><li><p>定义的位置不同【重点】</p><p>(1) 局部变量: 在方法的内部。</p><p>(2) 成员变量: 在方法的外部，直接写在类当中。</p></li><li><p>作用范围不同【重点】</p><p>(1) 局部变量: 在方法中才能使用，在方法外不能使用。</p><p>(2) 成员变量: 整个类都能使用。</p></li><li><p>默认值不一样【重点】</p><p>(1) 局部变量: 没有默认值，使用时必须手动赋值。</p><p>(2) 成员变量: 如果没有赋值，就会有默认值，规则与数组一样。</p></li><li><p>内存的位置不同</p><p>(1) 局部变量: 位于栈内存。</p><p>(2) 成员变量: 位于堆内存。</p></li><li><p>生命周期不同</p><p>(1) 局部变量: 随着方法进栈而诞生，随着方法出栈而消失。</p><p>(2) 成员变量: 随着对象创建而诞生，随着对象被垃圾回收而消失。</p></li></ol><h4 id="private关键字使用"><a href="#private关键字使用" class="headerlink" title="private关键字使用"></a>private关键字使用</h4><p>间接访问private成员变量，就是定义一对<strong>Getter/Setter方法</strong>。</p><p>必须叫setXxx和getXxx命名规则：</p><p>(1) 对于Getter: 不能有参数，返回值类型和成员变量对应。</p><p>(2) 对于Setter: 不能有返回值，参数类型和成员变量对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">// Setter    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Getter    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>对于基本数据类型boolean值，Getter方法一定要写成isXxx的形式，而setXxx规则不变。</li></ol><h4 id="this关键字使用"><a href="#this关键字使用" class="headerlink" title="this关键字使用"></a>this关键字使用</h4><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。</p><p>如果需要访问本类中的成员变量，需要使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量</span><br></pre></td></tr></table></figure><p>通过谁调用的方法，谁就是this。</p><hr><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>专门用来创建对象的方法，通过关键字new创建对象时，就是在调用构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="keyword">public</span> 类名(参数类型 参数名称) &#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li><p>构造方法名称必须和所在类的名称一致，大小写都要一致。</p></li><li><p>构造方法不要写返回值类型，void都不写。</p></li><li><p>构造方法没有return。</p></li></ol><hr><h3 id="一个标准的类"><a href="#一个标准的类" class="headerlink" title="一个标准的类"></a>一个标准的类</h3><p>包括四个组成部分：</p><ol><li>所有的成员变量都要使用private关键字修饰。</li><li>为每一个成员变量编写一对Getter/Setter方法。</li><li>编写一个无参数的构造方法。</li><li>编写一个全参数的构造方法。</li></ol><hr><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><p>抽象方法：加上abstract关键字，然后去掉大括号直接分号结束。</p><p>抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 定义一个普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用抽象类和抽象方法：</strong></p><ol><li><p>不能直接创建new抽象类对象。</p></li><li><p>必须用一个子类来继承抽象父类。</p></li><li><p>子类必须覆盖重写抽象父类中的<strong>所有的抽象方法</strong>。</p><p>覆盖重写(实现)：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</p></li><li><p>创建子类对象进行使用。</p></li></ol>]]></content>
    
    
    <summary type="html">Java面向对象的相关知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/20】Java开发基础知识点(一)</title>
    <link href="http://example.com/2021/12/17/0_%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/12/17/0_%E5%9F%BA%E7%A1%80/</id>
    <published>2021-12-17T12:28:46.315Z</published>
    <updated>2021-12-17T12:42:16.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>基本数据类型</strong></p><p>​    “四类八种”</p><p>​    整数型: byte short int long </p><p>​    浮点型: float double</p><p>​    字符型: char</p><p>​    布尔型: boolean</p><p><strong>引用数据类型</strong></p><p>​    字符串、数组、类、接口、Lambda</p><p><strong>注意事项：</strong></p><ol><li><p>字符串不是基本类型，而是引用类型。</p></li><li><p>浮点数是一个近似值，不是精确的值。</p></li><li><p>数据范围与字节数不一定相关。float是4字节，long是8字节。</p></li><li><p>浮点数默认是double类型，若想使用float类型，需要在后面加上F。</p><p>整数默认是int类型，若想使用long类型，需要在后面加上L。</p></li></ol><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>程序运行期间可以改变的量。</p><p><strong>创建变量</strong>的格式：数据类型 变量名称 = 数据值；</p><p><strong>注意事项：</strong></p><ol><li>创建多个变量时，变量之间的名称不可以重复。</li><li>对于float和long类型来说，字幕后缀的F和L不能去掉。</li><li>使用byte和short类型的变量，赋值不能超出左侧类型的范围。</li><li>没有进行赋值的变量，不能直接使用。</li><li>变量要在作用域的范围内使用。</li><li>可以通过一个语句定义多个变量，但不推荐使用。</li></ol><hr><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>数据类型不同时，会发生数据类型转换。</p><p><strong>自动类型转换(隐式)</strong></p><ol><li>代码不需要特殊处理，自动完成。</li><li>规则：数据范围从小到大。</li></ol><p><strong>强制类型转换(显式)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制类型转换</span></span><br><span class="line"><span class="comment">// 范围小的类型 范围小的变量名 = （范围小的类型） 原本范围大的数据</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) <span class="number">100L</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ol><li>强制类型转换容易造成数据<strong>精度损失、数据溢出</strong>。 </li><li>byte/short/char这三种类型都可以进行数学运算。</li><li>byte/short/char这三种类型进行数学运算时，首先将数据类型<strong>转换成int</strong>，再进行计算。</li><li>boolean类型不能进行数据类型转换。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> zifu1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(zifu1 + <span class="number">1</span>); <span class="comment">// 66</span></span><br><span class="line"><span class="comment">// 计算机底层会用数字(二进制)来代表字符A(65)</span></span><br><span class="line"><span class="comment">// char类型进行数据运算，字符就会按照规则翻译成一个数字。</span></span><br></pre></td></tr></table></figure><p>ASCII表:美国信息交换标准代码</p><p>Unicode表:万国表</p><p>48-‘0’;65-‘A’;98-‘a’</p><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>运算符：进行特定操作的符号，如’+’。</p><p>表达式：用运算符连接起来的式子叫表达式，如‘20+5’</p><p>四则运算、取模(%)</p><p>四则运算中的“+”有常见的三种用法：</p><ol><li>对于数值来说，就是加法。</li><li>对于字符char类型来说，在计算之前，先将char类型转变成int类型(依据ASCII表)，再进行计算。</li><li>对于字符串String来说，加号代表字符串连接操作。</li></ol><p>自增运算符：++ 自减运算符：–</p><p>使用格式：写在变量之前或是变量之后。</p><p>使用方式：</p><ol><li>单独使用：不和其他操作混合，自己独立成为一个步骤。</li><li>混合使用：和其他操作混合使用，如赋值或者打印。</li></ol><p>使用区别：</p><ol><li>单独使用时，前++和后++没有区别。</li><li>在混合的时候，有【区别】<ol><li>前++：变量立即加1，拿着结果使用。</li><li>后++：先使用变量原先的值，后再让变量+1。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独使用,二者没有区别。</span></span><br><span class="line">num++;</span><br><span class="line">++num;</span><br><span class="line"><span class="comment">// 混合使用</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">System.out.println(++num);<span class="comment">//先加后用</span></span><br><span class="line">System.out.println(num++);<span class="comment">//先用后加</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>运算过程中有不同的数据类型，结果是数据类型范围大的那种。</li></ol><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>(1)基本赋值运算符</p><p>就是一个“=”，代表将右侧数据传给左侧的变量。</p><p>(2)复合赋值运算符</p><p>+=、-=、*=、/=、%=</p><p><strong>注意事项</strong>：</p><ol><li>只有变量才能使用赋值运算符，常量不能进行赋值。</li><li>复合赋值运算符其中隐含有强制类型转换。</li></ol><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>==、&lt;、&gt;、&lt;=、&gt;=、!=</p><p><strong>注意事项</strong>：</p><ol><li>比较运算符的结果是boolean类型的，成立为true,不成立为false。</li><li>比较运算符不能连用。</li></ol><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>与(&amp;&amp;)：全都是true，才是true；否则是false。</p><p>或(||)：至少有一个是true，就是true；全都是false，才是false。</p><p>非(!)：取反。</p><p><strong>短路效果</strong>：“&amp;&amp;”和“||”,根据左边已经可以判断得到最终结果，那么右边的代码将不再执行，可以节省一定的性能。</p><p><strong>注意事项</strong>：</p><ol><li><p>逻辑运算符只能作用于boolean值。</p></li><li><p>与、或需要左右各自有一个boolean值，但是取反(非)只有一个唯一的boolean值即可。</p></li><li><p>与、或如果有多个条件，可以连续写。</p><p>两个条件：条件1 &amp;&amp; 条件2</p><p>三个条件：条件1 &amp;&amp; 条件2 &amp;&amp;  条件3</p></li></ol><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>一元运算符：只需要一个数据就可以进行操作的运算符。如取反！、自增++、自减–</p><p>二元运算符：需要两个数据才可以进行操作的运算符。例如：加法+、赋值=</p><p>三元运算符：需要三个数据才能进行操作的运算符。</p><p><strong>格式</strong>：</p><p>数据类型 变量名称 = 条件判断 ？ 表达式A ： 表达式B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = a &gt; b ? a : b;</span><br></pre></td></tr></table></figure><p>首先判断条件是否成立：</p><p>如果成立为true，那么表达式A的值赋值给左侧的变量；</p><p>如果不成立为false，那么将表达式B的值赋值给左侧的变量；</p><p><strong>注意事项</strong>：</p><ol><li>必须同时保证表达式A和表达式B都符合左侧的数据类型的要求。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误形式：</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">2.5</span> : <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>三元运算符的结果必须被使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a &gt; b ? a : b);<span class="comment">//正确写法</span></span><br><span class="line"><span class="comment">// a &gt; b ? a : b;//错误写法！</span></span><br></pre></td></tr></table></figure><hr><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p> 定义方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名称()&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义方法的完整形式：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">修饰符 返回值类型 方法名称(参数类型 参数名称， ...) &#123;</span></span><br><span class="line"><span class="comment">方法体</span></span><br><span class="line"><span class="comment">return 返回值;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1)修饰符:现阶段的固定写法,public static</span></span><br><span class="line"><span class="comment">(2)返回值类型:方法最终产生的数据结果是什么类型的。</span></span><br><span class="line"><span class="comment">(3)方法名称:方法的名字，规则同变量一样。小驼峰式命名。</span></span><br><span class="line"><span class="comment">(4)参数类型:进入方法的数据是什么类型。</span></span><br><span class="line"><span class="comment">(5)参数名称:进入方法的数据对应的变量名称。多个参数，用逗号隔开。</span></span><br><span class="line"><span class="comment">(6)方法体:方法的功能。</span></span><br><span class="line"><span class="comment">(7)return:两个作用。①停止当前的方法。②将后面的结果数据返回值还给调用处。</span></span><br><span class="line"><span class="comment">(8)返回值:方法执行后的最终产生的数据结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”保持对应。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>方法名称的命名规则和变量一样，使用小驼峰。</p><p>方法体:大括号内可以包含任意条语句。</p><p><strong>注意事项</strong>：</p><ol><li>方法定义的先后顺序无所谓。</li><li>方法不能嵌套定义。</li><li>方法定义完成后不会执行。需要进行方法的调用。</li><li>如果方法有返回值，那么必须写上“return 返回值;”，不能没有。</li><li>return后面的返回值数据，必须和方法的返回值类型对应起来。</li><li>对于void没有返回值的方法，布恩那个写return后面的返回值，只能写return自己。</li><li>void方法中的return可以不写。</li><li>一个方法中可以具有多个return语句，但是只能保证一个会被执行到。</li></ol><p><strong>方法调用</strong>：</p><ol><li>单独调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名称();</span><br></pre></td></tr></table></figure><ol start="2"><li>打印调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(方法名称(参数)</span><br></pre></td></tr></table></figure><ol start="3"><li>赋值调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名称 = 方法名称(参数)</span><br></pre></td></tr></table></figure><p><strong>方法的重载(overload)</strong></p><p>多个方法的名称一样，但是<strong>参数列表不一样</strong>。</p><p>只需要记住一个方法名称，就可以实现类似的多个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法重载与下列因素<strong>相关</strong>:</p><ol><li>参数的个数不同。</li><li>参数的类型不同。</li><li>参数的多类型顺序不同。</li></ol><p>与下列因素<strong>无关</strong>:</p><ol><li>与参数名称无关。</li><li>与方法的返回值类型无关。</li></ol><hr><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p><strong>“编译器的常量优化”</strong></p><p>在给变量进行赋值的时候，如果右侧表达式当中都是常量，没有任何变量，编译器的javac会将若干个常量表达式计算得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> result = <span class="number">5</span> + <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>一旦表达式中存在变量，不能进行这种优化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">short</span> result = <span class="number">5</span> + a + <span class="number">8</span>;<span class="comment">// 报错！</span></span><br></pre></td></tr></table></figure><hr><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>按照代码的顺序进行执行。</p><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><p>(1) if语句</p><p>(2) if…else语句:二者选其一。</p><p>(3) if…else if…else:n者选其一。</p><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><p>switch语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line"> <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line"> 语句体;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line"> 语句体;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> 语句体n+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li><p>多个case后面的数据值不能重复。</p></li><li><p>switch后面的小括号当中只能是下列数据类型：</p><p>基本数据类型: byte/short/int/char</p><p>引用数据类型: String字符串、enum枚举</p></li><li><p>switch语句的顺序可以灵活调整。</p></li></ol><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>(1) for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始表达式;布尔表达式;步进表达式) &#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环结构基本组成部分：</p><ol><li>初始化语句：循环开始最初执行，只执行一次。</li><li>条件判断：如果成立，继续执行循环；不成立，退出循环。</li><li>循环体：重复要做的事情内容，若干行语句。</li><li>步进语句：每次循环需要进行的扫尾工作。</li></ol><p>(2) while循环</p><p>标准格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件判断) &#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span> (条件判断) &#123;</span><br><span class="line">循环体;</span><br><span class="line">步进表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) do…while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体; <span class="comment">// 第一次无条件执行</span></span><br><span class="line">    步进语句;</span><br><span class="line">&#125; <span class="keyword">while</span> (条件判断);<span class="comment">// 末尾有一个&quot;;&quot;</span></span><br></pre></td></tr></table></figure><img src="/2021/12/17/0_%E5%9F%BA%E7%A1%80/1637218570540.png" class="" title="label"><p><strong>三种循环区别</strong>：</p><ol><li>如果条件判断没有满足过，那么for循环和while循环将执行0次，do-while循环会至少执行一次。</li><li>for循环的变量在小括号内定义，只能在循环内部使用。while和do-while初始化语句在外面定义，所以出循环后还可以继续使用。</li></ol><h4 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h4><p>(1) break语句的使用</p><ol><li>在switch语句中使用，一旦执行，整个switch语句立即结束。</li><li>在循环语句中使用，一旦执行，整个循环语句立刻结束。打断循环。</li></ol><p>(2) continue语句的使用</p><p>一旦执行，<strong>立即跳过当前循环剩余内容</strong>，马上开始下一次循环。</p><hr><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>快捷键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alt + enter <span class="comment">// 导入包，自动修正代码</span></span><br><span class="line">ctrl + y <span class="comment">// 删除行</span></span><br><span class="line">ctrl + d <span class="comment">// 复制行</span></span><br><span class="line">ctrl + alt + l <span class="comment">// 自动对齐，格式化代码</span></span><br><span class="line">ctrl + / <span class="comment">// 单行注释</span></span><br><span class="line">ctrl + shift + / <span class="comment">// 多行注释</span></span><br><span class="line">alt + ins <span class="comment">// 自动生成代码，toString,get,set方法</span></span><br><span class="line">alt + shift + 上下箭头 <span class="comment">// 移动当前代码行</span></span><br><span class="line">shift + F6 <span class="comment">// 替换所有的选中</span></span><br></pre></td></tr></table></figure><p>快捷循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> fori</span><br></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种容器，可以同时存储多个数据值。</p><p>数组的特点:</p><ol><li>数组是一种引用数据类型。</li><li>数组当中的多个数据，类型必须统一。</li><li>数组的长度在程序运行期间不能被改变。</li></ol><p>数组的初始化:</p><ol><li>动态初始化(指定长度)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[数组长度]</span><br></pre></td></tr></table></figure><p>​    使用动态初始化数组的时候，其中元素将自动拥有一个默认值。规则如下</p><p>​        (1) 整型(int): 0</p><p>​        (2) 浮点型(float): 0.0</p><p>​        (3) 字符类型(char): ‘\u0000’</p><p>​        (4) 布尔类型(boolean): false</p><p>​        (5) 引用类型: null</p><ol start="2"><li>静态初始化(指定内容)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[] &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, ...&#125;</span><br><span class="line"><span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>, <span class="number">15</span>, <span class="number">20</span>&#125;;</span><br></pre></td></tr></table></figure><p>访问数组的值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名称[索引值] <span class="comment">// 索引值从0开始，一直到数组长度-1</span></span><br></pre></td></tr></table></figure><p>获取数组的长度:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组名称.length <span class="comment">// 将得到数组的长度(int)</span></span><br><span class="line"><span class="comment">// 长度定义后，在运行期间没法改变。</span></span><br></pre></td></tr></table></figure><p>数组作为方法参数：</p><p>当调用方法的时候，向方法的小括号进行传参数，传递进去的其实是<strong>数组的地址值</strong>。</p><p>注意:</p><ol><li><p>初始化都可以拆成两个部分。</p></li><li><p>如果不确定数组中的具体内容，使用动态初始化；已经确定了具体的内容，使用静态初始化。</p></li><li><p>直接打印数组名称，得到的是数组对应的<strong>内存地址哈希值</strong>。</p></li><li><p>数组必须进行new初始化才能使用其中的元素。如果只是赋值了null,没有new创建，将会发生<strong>空指针异常</strong>。</p></li></ol><hr><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存划分为5个部分：</p><ol><li><p>栈(stack): 存放的都是方法中的局部变量。<strong>方法的运行一定在栈之中。</strong></p><p>​    局部变量：方法的参数，或者是方法{}内部的变量。</p><p>​    作用域：一旦超出作用域，立即从栈内存当中消失。</p></li><li><p><strong>堆(Heap): 凡是new出来的东西，都在堆之中。</strong></p><p>​    堆内存里面的东西都有一个地址值：16进制</p><p>​    堆内存里面的数据，都有默认值。[同初始化的默认值]</p></li><li><p>方法区(Method Area)：存储.class相关信息，包含方法的信息。</p></li></ol><ol start="4"><li>本地方法栈(Native Method Stack)：与操作系统有关。</li><li>寄存器(pc Register)：与CPU有关。</li></ol><img src="/2021/12/17/0_%E5%9F%BA%E7%A1%80/1637378335521.png" class="" title="label">]]></content>
    
    
    <summary type="html">包括常量、变量、运算符、方法等一些基础知识点</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/17】Git配置个人网站时一些操作记录</title>
    <link href="http://example.com/2021/12/17/1_git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/12/17/1_git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</id>
    <published>2021-12-17T03:41:59.980Z</published>
    <updated>2021-12-17T13:38:01.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git相关操作"><a href="#Git相关操作" class="headerlink" title="Git相关操作"></a>Git相关操作</h2><p>1.<code>clone</code> 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:Annoy0514/test.git // ssh的地址</span><br></pre></td></tr></table></figure><p>2.<strong>查看仓库状态</strong>,检查远程仓库跟本地仓库内容是否一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>3.本地仓库<strong>添加新内容</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add 添加的文件名 // 将文件添加到【临时缓冲区】</span><br><span class="line">$ git commit -m <span class="string">&quot;提交的信息&quot;</span>// 提交信息到本地仓库</span><br></pre></td></tr></table></figure><p>4.查看仓库的<strong>提交日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> // 查看仓库提交日志</span><br></pre></td></tr></table></figure><p>5.再输入<code>git status</code> 查看<strong>仓库状态</strong></p><p>6.输入<code>git push origin master</code> 将<strong>本地仓库提交到远程仓库</strong>,<code>origin</code> 是远程主机的名字。</p><p><strong>7.<code>Hexo</code> 主题更换语言</strong></p><p>打开站点配置文件： 站点根目录/_config.yml</p><img src="/2021/12/17/1_git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/1639736037457.png" class="" title="label"><img src="/2021/12/17/1_git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/1639736116629.png" class="" title="label"><p>搜索到language属性，将属性值进行修改。【en/zh-CN】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><p>然后重新打包部署。</p><p><strong>8.更换顶部背景</strong></p><p>找到butterfly配置文件_config.yml中的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the banner of page not setting, it will show the top_img</span></span><br><span class="line"><span class="attr">default_top_img:</span> <span class="string">&#x27;linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="hexo-三部曲"><a href="#hexo-三部曲" class="headerlink" title="hexo 三部曲"></a><code>hexo </code>三部曲</h2><p>设置主题后需要写的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用git配置个人网站的一些操作总结</summary>
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/12/16/hello-world/"/>
    <id>http://example.com/2021/12/16/hello-world/</id>
    <published>2021-12-16T11:21:12.138Z</published>
    <updated>2021-12-17T12:43:23.399Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【21/11/26】Java_API知识点</title>
    <link href="http://example.com/2021/11/22/3_API/"/>
    <id>http://example.com/2021/11/22/3_API/</id>
    <published>2021-11-22T13:29:19.684Z</published>
    <updated>2021-12-17T13:45:46.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JAVA中常用的API"><a href="#JAVA中常用的API" class="headerlink" title="JAVA中常用的API"></a>JAVA中常用的API</h2><p>API:应用程序编程接口</p><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><p>功能：可以实现 <strong>键盘输入</strong> 数据到程序之中。</p><ol><li><p>导包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包路径.类名称;</span><br></pre></td></tr></table></figure><p>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</p><p>只有java.lang包下的内容不需要导包，其他的包都需要import语句。</p></li><li><p>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名称 对象名 = <span class="keyword">new</span> 类名称();</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员方法名()</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>用来生成随机数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 创建</span></span><br><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 使用</span></span><br><span class="line"><span class="keyword">int</span> num = r.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定范围，左闭右开</span></span><br><span class="line">Random r2 = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> num2 = r2.nextInt(<span class="number">10</span>);  <span class="comment">// [0,10)范围内的随机数</span></span><br></pre></td></tr></table></figure><hr><h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p>数组的长度不能发生改变。ArrayList的长度可以发生改变。</p><p>ArrayList<E> :这个E代表泛型。</p><p><strong>泛型：</strong>装在集合中的所有的元素，统一都为什么类型。</p><p>注意事项：</p><ol><li><p>泛型只能是引用类型，不能是基本类型。</p></li><li><p>ArrayList直接打印得到的是内容。如果内容为空，则得到空的中括号[]。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 向集合中添加数据，要用到add方法。</span></span><br><span class="line">list.add(<span class="string">&quot;Jack&quot;</span>);</span><br></pre></td></tr></table></figure><p>常用的方法：</p><table><thead><tr><th>方法名</th><th>效果</th></tr></thead><tbody><tr><td>add</td><td>向集合中添加元素，参数的类型同泛型一致。返回值代表是否添加成功。</td></tr><tr><td>get</td><td>从集合中获取元素，参数是索引编号，返回值是对应位置的元素。</td></tr><tr><td>remove</td><td>从集合中删除元素，参数是索引编号，返回值是被删除的元素。</td></tr><tr><td>size</td><td>获取集合的尺寸长度，返回值是集合中包含的元素个数。</td></tr></tbody></table><p> 如果想要向集合ArrayList中<strong>存储基本类型数据</strong>，必须使用基本类型对应的<strong>包装类</strong>。</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer【特殊】</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character【特殊】</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><hr><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>字符串类。程序中的所有的双引号字符串，都是String类的对象。</p><p>特点：</p><ol><li>字符串是常量，字符串的内容永不可变。【重点】</li><li>字符串可以共享使用。</li><li>字符串底层原理是byte[]字节数组。效果上相当于char[]字符数组。</li></ol><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 使用空参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 根据字符数组创建字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] array)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 根据字节数组创建字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 直接创建</span></span><br><span class="line">String str = <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure><p>直接写上双引号，就是字符串。</p><p><strong>字符串常量池</strong></p><p>程序当中直接写上的双引号字符串，就在字符串常量池之中。</p><ol><li><p>对于基本类型，==是【数值】的比较。</p></li><li><p>对于引用类型，==是【地址值】的比较。</p></li></ol><p>对于new出的是字符串对象，不在字符串常量池中。 </p><p><strong>字符串比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public boolean equals(Object obj)</span></span><br><span class="line"><span class="comment">// 参数可以是任何对象，只有参数是一个字符串并且内容相同才会给true，否则都是false.</span></span><br><span class="line"><span class="comment">// 注意：如果比较双方一个常量一个变量，推荐把常量字符串写在前面。</span></span><br><span class="line">str1.equals(str2);</span><br></pre></td></tr></table></figure><p><strong>字符串获取</strong></p><p><strong>字符串截取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 截取从参数位置一直到字符串末尾，返回新字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">subString</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 截取从begin开始，一直到end结束，中间的字符串。[begin,end)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">subString</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>字符串转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 public char[] toCharArray():将当前字符串拆分成字符数组作为返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 public byte[] getBytes():获得当前字符串底层的字节数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 public String replace(CharSequence oldString, CharSequence newString):将所有出现的老字符串替换成新的字符串，返回替换之后的结果新字符串。</span></span><br></pre></td></tr></table></figure><p><strong>字符串切割</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照参数的规则，将字符串切成若干部分。</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br></pre></td></tr></table></figure><hr><h3 id="static关键词"><a href="#static关键词" class="headerlink" title="static关键词"></a>static关键词</h3><p>使用static关键词，<strong>内容不再属于对象自己，而是属于类的</strong>。</p><p>凡是本类的对象，都共享同一份。 </p><p>如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</p><p>如果有了static关键字，那么不需要创建对象，直接通过类名称使用它。</p><p>无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态变量：类名称.静态变量</span><br><span class="line">静态方法：类名称.静态方法<span class="comment">()</span></span><br></pre></td></tr></table></figure><img src="/2021/11/22/3_API/1637810518113.png" class="" title="img"><p>根据类名称访问静态成员变量的时候，全程和对象没有关系，只和类有关系。</p><p><strong>注意事项：</strong></p><ol><li>静态不能直接访问非静态。</li><li>静态方法当中不能用this。</li></ol><hr><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p>与数组相关的工具类，提供大量的静态方法，用来实现数组常见的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将参数数组变成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(数组)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照默认升序对数组元素进行排序</span></span><br><span class="line"><span class="comment">// (1)如果是数字，按照从小到大。(2)如果是字符串，按照字母升序。(3)如果是自定义类型，需要有Comparable或者Comparator接口的支持。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(数组)</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>数学相关的工具类，完成与数学运算相关的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> num)</span></span>;<span class="comment">// 获取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">// 向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">// 向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> num)</span></span>; <span class="comment">// 四舍五入</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录一些常用的API.</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
