<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Annoy</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-19T07:09:46.690Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Annoy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【21/12/15】Java_SpringMVC</title>
    <link href="http://example.com/2021/12/19/2_5_SpringMVC/"/>
    <id>http://example.com/2021/12/19/2_5_SpringMVC/</id>
    <published>2021-12-19T06:46:42.204Z</published>
    <updated>2021-12-19T07:09:46.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring相关内容"><a href="#Spring相关内容" class="headerlink" title="Spring相关内容"></a>Spring相关内容</h2><hr><h3 id="1-Web开发中请求-响应模型："><a href="#1-Web开发中请求-响应模型：" class="headerlink" title="1. Web开发中请求-响应模型："></a>1. Web开发中请求-响应模型：</h3><p>Web客户端发起请求，Web服务器接收、处理并产生相应。</p><h4 id="2-标准MVC-Model-View-Controller-模型"><a href="#2-标准MVC-Model-View-Controller-模型" class="headerlink" title="2. 标准MVC( Model-View-Controller )模型"></a>2. 标准MVC( Model-View-Controller )模型</h4><p>(1) <strong>Model( 模型 )</strong>: 数据模型，提供要展示的数据。为模型提供模型 <strong>数据查询</strong> 和 <strong>模型数据的状态更新</strong> 等功能，包括数据与业务。</p><p>(2) <strong>View( 视图 )</strong>: 负责对模型进行展示。【用户界面】</p><p>(3) <strong>Controller( 控制器 )</strong>: 接收用户请求，调度给模型进行处理，处理完毕将返回的模型数据传给视图，视图负责显示。【调度员】</p>]]></content>
    
    
    <summary type="html">Java中Spring相关内容。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/15】Java_基础知识点(二)</title>
    <link href="http://example.com/2021/12/18/2_4_%E5%9F%BA%E7%A1%80%E5%BC%BA%E5%8C%96/"/>
    <id>http://example.com/2021/12/18/2_4_%E5%9F%BA%E7%A1%80%E5%BC%BA%E5%8C%96/</id>
    <published>2021-12-18T14:16:01.090Z</published>
    <updated>2021-12-18T14:19:38.926Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="基础强化"><a href="#基础强化" class="headerlink" title="基础强化"></a>基础强化</h2><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a><code>Junit</code>单元测试</h3><p>测试分类：黑盒测试[不需要写代码]、白盒测试[需要写代码测试]</p><p>黑盒测试：给输入值，看程序是否能输出期望的值。</p><p>白盒测试：需要写代码。关注程序具体的执行流程。</p><ul><li><p>步骤</p><ol><li>定义一个测试类(测试用例)<ul><li>测试类名：<code>被测试的类名Test</code></li><li>包名：<code>xxx.xxx.xxx.test</code></li></ul></li><li>定义测试的方法：可以独立运行<ul><li>方法名：test测试的方法名        <code>testAdd()</code></li><li>返回值：<code>void</code></li><li>参数列表：空参</li></ul></li><li>给方法加<code>@Test</code></li><li>导入<code>junit</code>依赖环境</li></ol></li><li><p>判定结果：</p><p>​    绿色：成功</p><p>​    红色：失败</p><p>​    一般使用断言操作<code>Assert</code>来处理结果</p></li></ul><p>两个注解：<code>@Before</code> [执行测试方法之前执行] 和 <code>@After</code> [执行测试方法之后执行]。</p><hr><h3 id="反射：框架的设计灵魂"><a href="#反射：框架的设计灵魂" class="headerlink" title="反射：框架的设计灵魂"></a>反射：框架的设计灵魂</h3><p>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。</p><p><strong>反射机制</strong>：将类的各个组成部分封装成其他对象，这就是反射机制。</p><ul><li>好处：<ul><li>在程序的运行过程中操作这些对象。</li><li>可以解耦，提供程序的可扩展性。</li></ul></li></ul><p>获取<code>Class</code>对象的方式：</p><ol><li><code>Class.forName(&quot;全类名&quot;)</code>:将字节码文件加载进内存，返回Class对象。<ul><li>多用于配置文件中，将类名定义在配置文件中，读取文件，加载类。</li></ul></li><li><code>类名.class</code>：通过类名的属性class获取。<ul><li>多用于参数的传递。</li></ul></li><li><code>对象.getClass()</code>:<code>getClass()</code>方法在Object类中定义。<ul><li>多用于对象的获取字节码的方式。</li></ul></li></ol><p>注：同一字节码文件<code>*.class</code> 在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。</p><p><code>Class</code>对象功能：</p><ol><li><p>获取成员变量们</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo23_Reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Class获取功能：</span></span><br><span class="line"><span class="comment">*       获取成员变量们：</span></span><br><span class="line"><span class="comment">*           1.Field[] getFields() 获取所有的public修饰的成员变量。</span></span><br><span class="line"><span class="comment">*           2.Field getField(String name) 获取指定名称的public修饰的成员变量</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*           3.Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符。</span></span><br><span class="line"><span class="comment">*           4.Field getDeclaredField(String name)</span></span><br><span class="line"><span class="comment">*       操作：</span></span><br><span class="line"><span class="comment">*           1.设置值</span></span><br><span class="line"><span class="comment">*           2.获取值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Filed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 0.获取Person的Class对象</span></span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        Field[] fields = personClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field a = personClass.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取成员变量a的值</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Object value = a.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">// 设置a的值</span></span><br><span class="line">        a.set(p,<span class="string">&quot;菲利普&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符。</span></span><br><span class="line">        Field[] declaredFields = personClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(declaredField);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.Field getDeclaredField(String name)</span></span><br><span class="line">        Field d = personClass.getDeclaredField(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">// 忽略权限修饰符的安全检查</span></span><br><span class="line">        d.setAccessible(<span class="keyword">true</span>); <span class="comment">// 暴力反射</span></span><br><span class="line">        Object value2 = d.get(p);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo23_Reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   获取构造的方法</span></span><br><span class="line"><span class="comment">*       Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line"><span class="comment">*       Constructor&lt;T&gt; getConstructors(类&lt;?&gt;... parameter Types)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameter Types)</span></span><br><span class="line"><span class="comment">*       Constructor&lt;?&gt;[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment">*   创建对象：</span></span><br><span class="line"><span class="comment">*       T newInstance(Object... initargs);</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02_Constructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的class对象</span></span><br><span class="line">        Class personClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor&lt;T&gt; getConstructors(类&lt;?&gt;... parameter Types)</span></span><br><span class="line">        Constructor constructor = personClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Object person = constructor.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空参构造方法</span></span><br><span class="line">        Constructor constructor1 = personClass.getConstructor();</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Object person1 = constructor1.newInstance();</span><br><span class="line">        System.out.println(person1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化空参构造方法</span></span><br><span class="line">        Object o = personClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>获取成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo23_Reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   获取成员方法：</span></span><br><span class="line"><span class="comment">*       Method[] getMethod()</span></span><br><span class="line"><span class="comment">*       Method getMethod(String name, 类&lt;T&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       Method[] getDeclaredMethod()</span></span><br><span class="line"><span class="comment">*       Method getDeclaredMethod(String name, 类&lt;T&gt;... parameterTypes)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03_Method</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 0.创建一个class对象</span></span><br><span class="line">        Class peronClass = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指定的方法</span></span><br><span class="line">        Method eat_method = peronClass.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        eat_method.invoke(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Method eat_food_method = peronClass.getMethod(<span class="string">&quot;eat_food&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        eat_food_method.invoke(p,<span class="string">&quot;饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类名</span></span><br><span class="line">        String className = peronClass.getName();</span><br><span class="line">        System.out.println(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>反射案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo23_Reflect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   案例：</span></span><br><span class="line"><span class="comment">*       需求：写一个框架，在不改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中的任意方法。</span></span><br><span class="line"><span class="comment">*       实现：</span></span><br><span class="line"><span class="comment">*           1.配置文件</span></span><br><span class="line"><span class="comment">*           2.反射</span></span><br><span class="line"><span class="comment">*       步骤：</span></span><br><span class="line"><span class="comment">*           1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中。</span></span><br><span class="line"><span class="comment">*           2.在程序中加载读取配置文件。</span></span><br><span class="line"><span class="comment">*           3.使用反射技术来加载类文件进内存。</span></span><br><span class="line"><span class="comment">*           4.创建对象。</span></span><br><span class="line"><span class="comment">*           5.执行方法。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04_ReflectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载配置文件</span></span><br><span class="line">        <span class="comment">// 1.1创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 1.2加载配置文件，转化成一个集合</span></span><br><span class="line">        <span class="comment">// 1.2.1获取class目录下的配置文件</span></span><br><span class="line">        ClassLoader classLoader = Demo04_ReflectTest.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取配置文件中定义的数据</span></span><br><span class="line">        String className = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodName = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.加载该类进内存</span></span><br><span class="line">        Class cls = Class.forName(className);</span><br><span class="line">        <span class="comment">// 4.创建对象</span></span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        <span class="comment">// 5.获取方法对象</span></span><br><span class="line">        Method method = cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">// 6.执行方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="注解-【不太明白】"><a href="#注解-【不太明白】" class="headerlink" title="注解 【不太明白】"></a>注解 【不太明白】</h3><p>注解：说明程序的，给计算机看的。</p><p>注释：用文字描述程序。给开发人员看的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDEA中添加注解的方式: /**... + Enter</span></span><br><span class="line">    <span class="comment">/**..</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>作用分类：</p><ol><li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li><li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li><li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li></ol><p><code>JDK</code> 中预定义的一些注解：</p><ol><li><code>@Override</code> : 检测被该注解标注的方法是否继承自父类(接口)的。</li><li><code>Deprecated</code> : 该注解标注的内容，表示已过时。</li><li><code>SuppressWarning</code> : 压制警告。</li></ol><p>自定义注解：</p><ol><li><p>元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span> <span class="comment">// 描述注解能作用的位置</span></span><br><span class="line"><span class="meta">@Retention</span> <span class="comment">// 描述注解被保留的阶段</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">// 描述注解是否被抽取到api文档中</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 描述注解是否被子类继承</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">    <span class="comment">// 属性列表;(本质就是成员方法)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本质：注解的本质就是一个接口，该接口默认继承Annotation接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性：接口中可以定义的成员方法。接口中的抽象方法。</p><p>​    要求：（1）属性的返回值是(基本数据类型、String、枚举、注解、以上类型的数组)。</p><p>​                （2）定义了属性，在使用时需要给属性赋值。</p><p>​                        ① 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</p><p>​                        ② 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略。</p><p>​                        ③ 数组赋值时，使用{}包裹。</p></li></ol><p><code>Demo01_Anno.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo24_Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.tree.analysis.Value;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="comment">// 8888888888888888888888888888888888888888888888888888888</span></span><br><span class="line"><span class="meta">@MyAnno(value = 1,per = Person.P1,anno2 = @MyAnno2,strs = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;)</span> <span class="comment">// 添加注解的方式</span></span><br><span class="line"><span class="comment">// 8888888888888888888888888888888888888888888888888888888</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Anno</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有缺陷</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 替代show1方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>MyAnno.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo24_Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="comment">//int age();</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    String[] strs();</span><br><span class="line">    <span class="function">Person <span class="title">per</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MyAnno2 <span class="title">anno2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Person.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo24_Annotation;</span><br><span class="line"><span class="comment">// 枚举类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span>  <span class="title">Person</span> </span>&#123;</span><br><span class="line">    P1,P2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>MyAnno2.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo24_Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno2 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>以后大多数时间，仅仅是使用注解而不是自定义注解。</li><li>注解给谁用？<ol><li>编译器</li><li>解析程序</li></ol></li><li>注解不是程序的一部分。</li></ol><hr>]]></content>
    
    
    <summary type="html">Java中基础知识点总结(二)。【单元测试、框架、注解】</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/14】Java_Stream流</title>
    <link href="http://example.com/2021/12/18/2_3_Stream%E6%B5%81/"/>
    <id>http://example.com/2021/12/18/2_3_Stream%E6%B5%81/</id>
    <published>2021-12-18T14:13:43.623Z</published>
    <updated>2021-12-18T14:15:35.846Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>对集合和数组进行优化操作。</p><p><code>Stream流</code> 是一个集合元素的函数模型，调用指定的方法可以从一个流模型转换成另一个流模型。其本身**并不存储任何元素(或地址值)**。</p><p><code>Stream流</code>的基础特征：</p><ol><li>Pipelining：中间操作的对象都会返回流本身。多个操作可以串联成一个管道，如同流式风格(fluent style)。这样可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting).    <code>Stream流</code>属于管道流，只能被消费一次。</li><li>内部迭代：之前的遍历操作通过Iterator或者增强for循环进行操作，显式的在集合外部进行迭代。Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ol><p>流模型常用<code>API</code>，方法可以被分为两种：</p><ol><li><strong>延迟方法</strong>：返回值类型仍是 <code>Stream</code> 接口自身类型的方法，支持<strong>链式调用</strong>。（除了终结方法，其余方法都是延迟方法）</li><li><strong>终结方法</strong>：返回值类型不再是 <code>Stream</code> 接口自身类型的方法，因此不再支持类似 <code>StringBuilder</code> 那样的链式调用。终结方法包括 <code>count</code> 和 <code>forEach</code> 方法。</li></ol><hr><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><code>Demo01List.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo21_Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   使用传统方式遍历集合，对集合中的数据进行过滤。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01List</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个List集合，存储姓名。</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list集合中的元素进行过滤，只要以张开头的元素，存储到一个新的集合中去</span></span><br><span class="line">        List&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                listA.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对集合listA中的元素进行过滤，只要长度为3的元素，存储到新的集合中去</span></span><br><span class="line">        List&lt;String&gt; listB = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : listA) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.length()==<span class="number">3</span>) &#123;</span><br><span class="line">                listB.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印listB</span></span><br><span class="line">        <span class="keyword">for</span> (String s : listB) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Demo02Stream.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo21_Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Stream流关注的是做什么而不是怎么做。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Stream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个List集合，存储姓名。</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list集合中的元素进行过滤，只要以张开头的元素，存储到一个新的集合中去</span></span><br><span class="line">        <span class="comment">// 对集合listA中的元素进行过滤，只要长度为3的元素，存储到新的集合中去</span></span><br><span class="line">        <span class="comment">// 打印listB</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(name-&gt;name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .filter(name-&gt;name.length()==<span class="number">3</span>)</span><br><span class="line">                .forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><code>Demo03StreamUse.java</code>：Stream流的一些方法的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo21_Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.util.stream.Stream&lt;T&gt;是java8新加入的常用的流接口(并不是一个函数式接口)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   获取一个流有以下几种方式</span></span><br><span class="line"><span class="comment">*       1. 所有的Collection集合都可以通过stream默认方法获取流。</span></span><br><span class="line"><span class="comment">*           default Stream&lt;E&gt; stream()</span></span><br><span class="line"><span class="comment">*       2. Stream接口的静态方法of可以获取数组对应的流。</span></span><br><span class="line"><span class="comment">*           static &lt;T&gt; Stream&lt;T&gt; of (T... value)</span></span><br><span class="line"><span class="comment">*           参数是一个可变参数，我们可以传递一个数组。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03StreamUse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把集合转换为Stream流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取map集合中的键</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream3 = keySet.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取map集合中的值</span></span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream4 = values.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取键值对</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream5 = entries.stream();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组转换成Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 可变参数传递数组</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream7 = Stream.of(arr);</span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;dd&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream8 = Stream.of(arr2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   如果需要将流中的元素映射到另一个流中，可以使用map方法。</span></span><br><span class="line"><span class="comment">        *   &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span></span><br><span class="line"><span class="comment">        *   该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换成另一种R类型的流。</span></span><br><span class="line"><span class="comment">        *   Function中的抽象方法：</span></span><br><span class="line"><span class="comment">        *       R apply(T t);</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">// 获取一个String类型的Stream流</span></span><br><span class="line">        Stream&lt;String&gt; mapStream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用map方法把字符串类型的整数，转换(映射)为Integer类型的整数</span></span><br><span class="line">        Stream&lt;Integer&gt; int_stream = mapStream.map((String s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">        &#125;);</span><br><span class="line">        int_stream.forEach(i-&gt; System.out.print(i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   Stream流中常用的方法 count:用于统计Stream流中元素的个数。</span></span><br><span class="line"><span class="comment">        *   long count();</span></span><br><span class="line"><span class="comment">        *   count方法是一个终结方法，返回值是一个long类型的整数。</span></span><br><span class="line"><span class="comment">        *   所以不能再调用Stream流中的方法了。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list_count = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list_count.add(<span class="number">1</span>);</span><br><span class="line">        list_count.add(<span class="number">2</span>);</span><br><span class="line">        list_count.add(<span class="number">3</span>);</span><br><span class="line">        list_count.add(<span class="number">4</span>);</span><br><span class="line">        list_count.add(<span class="number">5</span>);</span><br><span class="line">        list_count.add(<span class="number">6</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream_count = list_count.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream_count.count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   Stream流中常用的方法 limit:用于截取流中的元素。</span></span><br><span class="line"><span class="comment">        *   limit方法可以对流进行截取，只取用前n个。</span></span><br><span class="line"><span class="comment">        *   Stream&lt;T&gt; limit(long maxSize);</span></span><br><span class="line"><span class="comment">        *       参数是一个long型，如果集合当前长度大于参数则进行截取；否则不操作。</span></span><br><span class="line"><span class="comment">        *   limit是一个延迟方法，只是对流中的元素进行截取，返回的是一个新的流，所以可以继续调用Stream流中的其他方法。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        String[] arr3 = &#123;<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>,<span class="string">&quot;ddd&quot;</span>,<span class="string">&quot;eee&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream_limit = Stream.of(arr3);</span><br><span class="line">        Stream&lt;String&gt; limit = stream_limit.limit(<span class="number">3</span>);</span><br><span class="line">        limit.forEach(name-&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   希望跳过前面几个元素，可以使用skip方法获取一个截取之后的新流：</span></span><br><span class="line"><span class="comment">        *   Stream&lt;T&gt; skip(long n);</span></span><br><span class="line"><span class="comment">        *   如果流的当前长度大于n，则跳过前n个；否则将得到一个长度为0的空流。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; skip = original.skip(<span class="number">2</span>);</span><br><span class="line">        System.out.println(skip.count());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   如果两个流，希望合并成一个流，可以使用Stream接口的静态方法concat.</span></span><br><span class="line"><span class="comment">        *   static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt;a, Stream&lt;? extends T&gt;b)</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Stream&lt;String&gt; aaa = Stream.of(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; bbb = Stream.of(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = Stream.concat(aaa, bbb);</span><br><span class="line">        result.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p><code>Demo04_StreamTest.java</code> :集合元素的处理(使用Stream和不使用Stream)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo21_Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   练习：集合元素的处理(传统方式)</span></span><br><span class="line"><span class="comment">*       现有两个ArrayList集合中有多个成员，按照以下要求对成员进行筛选。</span></span><br><span class="line"><span class="comment">*       1.第一个集合中只要名字为3个字的成员姓名，存储到一个新的集合中。</span></span><br><span class="line"><span class="comment">*       2.第一个队伍筛选完后只要前3个人，存储到一个新的集合中。</span></span><br><span class="line"><span class="comment">*       3.第二个队伍中只要姓名为”张“的成员，存储到一个集合中。</span></span><br><span class="line"><span class="comment">*       4.第二个队伍筛选完后不要前两个人，存储到一个新的集合中。</span></span><br><span class="line"><span class="comment">*       5.将两个队伍筛选完后的结果合并成一个新的队伍，存储到一个集合中。</span></span><br><span class="line"><span class="comment">*       6.根据姓名创建Person对象，存储到一个新的集合中。</span></span><br><span class="line"><span class="comment">*       7.打印整个Person对象信息。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04_StreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;盖伦&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;金克丝&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;拉克丝&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;易&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;伊泽瑞尔&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;崔斯特&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;薇古丝&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.第一个集合中只要名字为3个字的成员姓名，存储到一个新的集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list1) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.length()==<span class="number">3</span>) &#123;</span><br><span class="line">                one.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.第一个队伍筛选完后只要前3个人，存储到一个新的集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; one1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            one1.add(one.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream进行优化</span></span><br><span class="line">        Stream&lt;String&gt; oneStream = one.stream().filter(name-&gt;name.length()==<span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;张起灵&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;马儿扎哈&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;张杰&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.第二个队伍中只要姓名为”张“的成员，存储到一个集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt;  two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                two.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.第二个队伍筛选完后只要前两个人，存储到一个新的集合中。</span></span><br><span class="line">        ArrayList&lt;String&gt; two1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; two.size(); i++) &#123;</span><br><span class="line">            two1.add(two.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Stream进行优化</span></span><br><span class="line">        Stream&lt;String&gt; twoStream = two.stream().filter(name-&gt;name.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.将两个队合并成一个集合</span></span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.addAll(one1);</span><br><span class="line">        result.addAll(two1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.根据姓名创建Person对象，存储到一个新集合中。</span></span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : result) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Person(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7.打印输出</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : list) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Stream进行合并</span></span><br><span class="line">        Stream.concat(oneStream,twoStream).map(name-&gt;<span class="keyword">new</span> Person(name)).forEach(p-&gt; System.out.println(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中Stream流相关内容。【三个案例】</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/13】Java_函数式接口</title>
    <link href="http://example.com/2021/12/18/2_2_%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2021/12/18/2_2_%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</id>
    <published>2021-12-18T14:11:31.841Z</published>
    <updated>2021-12-18T14:13:37.085Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>适用于函数式编程[Lambda]。</p><p><code>Demo01_MyFunctionalInterface.java</code> : 定义一个函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo19_FunctionalInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   函数式接口：有且仅有一个抽象方法的接口，称之为函数式接口。</span></span><br><span class="line"><span class="comment">*   接口中还可以有别的方法(默认，静态，私有)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   @FunctionalInterface注解</span></span><br><span class="line"><span class="comment">*   作用：可以检测接口是否是一个函数式接口</span></span><br><span class="line"><span class="comment">*       是：编译成功</span></span><br><span class="line"><span class="comment">*       否：编译失败(接口中没有抽象方法或是抽象方法的个数多于1个)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo01_MyFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>MyFunctionalInterfaceImpl</code> : 定义接口的实现类对象，重写其抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo19_FunctionalInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFunctionalInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">Demo01_MyFunctionalInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Demo.java</code> : 测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo19_FunctionalInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*       函数式接口的使用：一般可以作为方法的参数和返回值类型。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Demo01_MyFunctionalInterface inter)</span> </span>&#123;</span><br><span class="line">        inter.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用show方法，方法的参数是一个接口，所以可以传递接口的实现类对象。</span></span><br><span class="line">        show(<span class="keyword">new</span> MyFunctionalInterfaceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用show方法，方法的参数是一个接口，所以我们可以传递接口的匿名内部类</span></span><br><span class="line">        show(<span class="keyword">new</span> Demo01_MyFunctionalInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写接口中的抽象方法！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用show方法，方法的参数是一个函数式接口，所以我们可以Lambda表达式</span></span><br><span class="line">        show(()-&gt; System.out.println(<span class="string">&quot;使用Lambda表达式重写接口中的抽象方法！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><code>Lambda表达式</code> ：延迟加载。</p><h3 id="函数式接口作为方法的参数"><a href="#函数式接口作为方法的参数" class="headerlink" title="函数式接口作为方法的参数"></a>函数式接口作为方法的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo20_Lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法startThread,方法的参数使用函数式接口Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable run)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用startThread方法，方法的参数是一个接口，可以考虑使用这个接口的匿名内部类</span></span><br><span class="line">        startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+<span class="string">&quot;线程启动！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用startThread方法，方法的参数是一个函数式接口，可以传递Lambda表达式</span></span><br><span class="line">        startThread(()-&gt; System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+<span class="string">&quot;线程启动！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数式接口作为方法的返回值类型"><a href="#函数式接口作为方法的返回值类型" class="headerlink" title="函数式接口作为方法的返回值类型"></a>函数式接口作为方法的返回值类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo20_Lambda;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*          一个方法的返回值是一个函数式接口，那么就可以直接返回一个Lambda表达式。</span></span><br><span class="line"><span class="comment">*           当需要一个方法来获取一个java.util.Comparator接口类型的对象作为排序器时，就可以调用该方法获取。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02_Comparator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个方法，方法的返回值类型使用函数式接口Comparator</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">getComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(String o1,String o2) &#123;</span></span><br><span class="line"><span class="comment">//                // 字符串的降序排序</span></span><br><span class="line"><span class="comment">//                return o2.length()-o1.length();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法的返回值类型是一个函数式接口，所以我们可以返回一个Lambda表达式</span></span><br><span class="line">        <span class="keyword">return</span> (String o1,String o2)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 字符串的降序排序</span></span><br><span class="line">            <span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续优化Lambda表达式</span></span><br><span class="line">        <span class="comment">//return ((o1, o2) -&gt; o2.length()-o1.length());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个字符串数组</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;dd&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 输出字符串</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// 调用Arrays中的sort方法，对字符串数组进行排序</span></span><br><span class="line">        Arrays.sort(arr,getComparator());</span><br><span class="line">        <span class="comment">// 输出排序后的结果</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中函数式接口相关内容。【Lambda】</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/13】Java_网络编程</title>
    <link href="http://example.com/2021/12/18/2_1_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/12/18/2_1_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-12-18T14:06:36.201Z</published>
    <updated>2021-12-18T14:10:50.491Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="(1) 软件结构"></a>(1) 软件结构</h3><p><code>C/S结构</code> :客户端/服务器。</p><p><code>B/S结构</code> :浏览器/服务器。</p><p><code>TCP</code> :传输控制协议。面两连接的通信协议。提供可靠的无差错的数据传输。每次传输需要经过<strong>三次握手</strong>。</p><p><code>UDP</code> :用户数据报协议。面向无连接性。不保证数据的完整性。但是传输速度快。</p><hr><h3 id="2-网络编程三要素"><a href="#2-网络编程三要素" class="headerlink" title="(2)网络编程三要素"></a>(2)网络编程三要素</h3><p><code>协议</code> [计算机通信需要遵守的规则]、<code>IP地址</code> [互联网协议地址]、<code>端口号</code> [两个字节组成，取值范围0-65535之间]</p><p>查看本地IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ipconfig</span><br></pre></td></tr></table></figure><p>检查网络是否连通：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping ip地址</span><br></pre></td></tr></table></figure><p>通信必须保证数据准确无误的发送到对象计算机的软件上。[使用<strong>IP地址+端口号</strong>]</p><p>一些常见的<code>端口号</code> :</p><ol><li>80端口，网络端口。</li><li>数据库  mysql: 3306 oracle: 1521</li><li>Tomcat服务器：8080</li></ol><hr><h3 id="3-TCP通信程序"><a href="#3-TCP通信程序" class="headerlink" title="(3) TCP通信程序"></a>(3) TCP通信程序</h3><p>TCP通信实现两台计算机之间的数据交互，通信的两端严格区分**客户端(Client)和服务端(Server)**。</p><p>通信的步骤：</p><p>服务器端先启动，服务器端不会主动的请求客户端，必须使用客户端请求服务器端。</p><p>客户端和服务器端建立一个逻辑链接，这个连接中包含一个对象，这个对象就是<strong>IO对象</strong>。</p><p>客户端与服务器端就可以使用IO对象进行通信。</p><p>通信的不止是字符，所以IO对象是<strong>字节流对象</strong>。</p><p>服务器端需要明确的事情：</p><ol><li>多个客户端同时与服务器进行交互，服务器必须明确和哪个客户端进行交互。在服务器端有一个方法，叫accept客户端获取到请求的客户端对象。</li><li>多个客户端同时和服务器进行交互，就需要使用多个IO流对象。</li><li><font color=red>服务器端使用客户端的流和客户端交互。</font></li></ol><h4 id="实验1：测试服务器端与客户端进行通信"><a href="#实验1：测试服务器端与客户端进行通信" class="headerlink" title="实验1：测试服务器端与客户端进行通信"></a>实验1：测试服务器端与客户端进行通信</h4><p><code>Demo01_TCPClient.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo18_Net;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   TCP通信的客户端：向服务器发送请求，给服务器发送数据，读取服务器返回的数据。</span></span><br><span class="line"><span class="comment">*   表示客户端的类：</span></span><br><span class="line"><span class="comment">*       java.net.Socket:此类实现客户端套接字(&quot;套接字&quot;)，套接字是两台机器间通信的端点。</span></span><br><span class="line"><span class="comment">*       套接字：包含了IP地址和端口号的网络单位。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       Socket(String host, int port) 创建一个流套接字并将其连接到指定主机的指定端口号。</span></span><br><span class="line"><span class="comment">*       参数：</span></span><br><span class="line"><span class="comment">*           String host： 服务器主机的名称/服务器的IP地址</span></span><br><span class="line"><span class="comment">*           int port: 服务器的端口号。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   成员方法：</span></span><br><span class="line"><span class="comment">*       OutputStream getOutputStream() 返回此套接字的输出流。</span></span><br><span class="line"><span class="comment">*       InputStream getInputStream() 返回此套接字的输入流。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建一个客户端对象Socket，构建方法绑定服务器的IP地址和端口号。</span></span><br><span class="line"><span class="comment">*       2. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment">*       3. 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。</span></span><br><span class="line"><span class="comment">*       4. 使用Socket对象中的方法getInputStream获取网络字节输入流InputStream对象。</span></span><br><span class="line"><span class="comment">*       5. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。</span></span><br><span class="line"><span class="comment">*       6. 释放资源。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. 客户端和服务器进行交互，必须使用Socket中提供的网络流，不能自己创建流对象。</span></span><br><span class="line"><span class="comment">*       2. 当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过三次握手建立连接通路。</span></span><br><span class="line"><span class="comment">*               这时如果服务器没有启动，那么就会抛出异常</span></span><br><span class="line"><span class="comment">*               如果服务器已经启动，就可以进行交互了。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个客户端对象Socket，构建方法绑定服务器的IP地址和端口号。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 2. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。</span></span><br><span class="line">        os.write(<span class="string">&quot;你好服务器&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4. 使用Socket对象中的方法getInputStream获取网络字节输入流InputStream对象。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 5. 使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">// 6. 释放资源。</span></span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Demo02_Server.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo18_Net;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   TCP通信的服务器端：接收客户端的请求，读取客户端发送的数据，给客户端返回数据。</span></span><br><span class="line"><span class="comment">*   表示服务器的类：</span></span><br><span class="line"><span class="comment">*       java.net.ServerSocket:此类实现服务器套接字。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       ServerSocket(int port) 创建绑定到指定端口的服务器套接字</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   服务器端必须明确一件事情，必须要知道是哪个客户端请求的服务器。</span></span><br><span class="line"><span class="comment">*   所以使用accept方法获取到请求的客户端对象Socket</span></span><br><span class="line"><span class="comment">*   成员方法：</span></span><br><span class="line"><span class="comment">*       Socket accept() 侦听并接收此套接字的连接。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   服务器端的实现步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建服务器ServerSocket对象和系统指定得端口号。</span></span><br><span class="line"><span class="comment">*       2. 使用ServerSocket对象中的方法accept，获取道请求的客户端对象Socket。</span></span><br><span class="line"><span class="comment">*       3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。</span></span><br><span class="line"><span class="comment">*       4. 使用InputStream对象中的方法read，读取客户端发送的请求数据。</span></span><br><span class="line"><span class="comment">*       5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment">*       6. 使用OutputStream对象中的方法write，给客户端回写数据。</span></span><br><span class="line"><span class="comment">*       7. 释放资源(Socket,ServerSocket)。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建服务器ServerSocket对象和系统指定得端口号。</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 2. 使用ServerSocket对象中的方法accept，获取道请求的客户端对象Socket。</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4. 使用InputStream对象中的方法read，读取客户端发送的请求数据。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">// 5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 6. 使用OutputStream对象中的方法write，给客户端回写数据。</span></span><br><span class="line">        os.write(<span class="string">&quot;收到&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 7. 释放资源(Socket,ServerSocket)。</span></span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="实验2-TCP通信实现文件的上传"><a href="#实验2-TCP通信实现文件的上传" class="headerlink" title="实验2: TCP通信实现文件的上传"></a>实验2: TCP通信实现文件的上传</h4><p><strong>原理:</strong> 客户端读取本地的文件，上传至服务器，服务器将上传的文件保存到服务器硬盘上。</p><p><strong>流程:</strong> </p><ol><li>客户端使用<font color=blue>本地字节输入流</font>，读取要上传的文件。</li><li>客户端使用<font color=green>网络字节输出流</font>，把读取到的文件上传至服务器。</li><li>服务器使用<font color=green>网络字节输入流</font>，读取客户端上传的文件。</li><li>服务器使用<font color=blue>本地字节输出流</font>，把读取到的文件，保存到服务器的硬盘上。</li><li>服务器使用<font color=green>网络字节输出流</font>，给客户端回写“上传成功”。</li><li>客户端使用<font color=green>网络字节输入流</font>，读取服务器回写的数据。</li><li>释放资源。</li></ol><p><strong>注意:</strong> </p><ol><li>客户端和服务器的本地硬盘进行读写，需要使用自己创建的字节流对象(本地流)。</li><li>客户端和服务器进行读写，必须使用Socket中提供的字节流对象(网络流)。</li><li>文件上传的原理，就是文件的复制。明确数据源、数据目的地。</li></ol><p><code>FileUploadClient.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo18_Net;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   文件上传案例的客户端：读取本地文件，上传至服务器，读取服务器回写的数据。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   明确：</span></span><br><span class="line"><span class="comment">*       数据源：</span></span><br><span class="line"><span class="comment">*       目的地：服务器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1.创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源。</span></span><br><span class="line"><span class="comment">*       2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号。</span></span><br><span class="line"><span class="comment">*       3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment">*       4.使用本地字节输入流FileInputStream对象中的方法read，读取本地文件。</span></span><br><span class="line"><span class="comment">*       5.使用网络字节输出流OutputStream对象中的方法write，将读取的本地文件的数据上传至服务器。</span></span><br><span class="line"><span class="comment">*       6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象.</span></span><br><span class="line"><span class="comment">*       7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据。</span></span><br><span class="line"><span class="comment">*       8.释放资源（FileInputStream,Socket）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03_FileUploadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源。</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\client_upload\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建一个客户端Socket对象，构造方法中绑定服务器的IP地址和端口号。</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 4.使用本地字节输入流FileInputStream对象中的方法read，读取本地文件。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 5.使用网络字节输出流OutputStream对象中的方法write，将读取的本地文件的数据上传至服务器。</span></span><br><span class="line">            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上传完文件，给服务器写一个结束标记。</span></span><br><span class="line">        <span class="comment">// void shutdownOutput() 禁用此套接字的输出流</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象.</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据。</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.释放资源（FileInputStream,Socket）</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>FileUploadServer.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo18_Net;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   文件上传案例的服务器端：读取本地文件，上传至服务器，读取服务器回写的数据。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   明确：</span></span><br><span class="line"><span class="comment">*       数据源：</span></span><br><span class="line"><span class="comment">*       目的地：服务器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1.创建一个服务器ServerSocket对象，和系统要指定的端口号。</span></span><br><span class="line"><span class="comment">*       2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象。</span></span><br><span class="line"><span class="comment">*       3.使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象。</span></span><br><span class="line"><span class="comment">*       4.判断是否存在文件夹(d:\\upload)，不存在则创建。</span></span><br><span class="line"><span class="comment">*       5.创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line"><span class="comment">*       6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件。</span></span><br><span class="line"><span class="comment">*       7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上。</span></span><br><span class="line"><span class="comment">*       8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment">*       9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”</span></span><br><span class="line"><span class="comment">*       10.释放资源(FileOutputStream,Socket,ServerSocket)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04_FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个服务器ServerSocket对象，和系统要指定的端口号。</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象。</span></span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 3.使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象。</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 4.判断是否存在文件夹(d:\\upload)，不存在则创建。</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\upload&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(file.exists())) &#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file+<span class="string">&quot;\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件。</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上。</span></span><br><span class="line">            fos.write(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”</span></span><br><span class="line">        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 10.释放资源(FileOutputStream,Socket,ServerSocket)</span></span><br><span class="line">        fos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优化<code>FileUploadServer.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo18_Net;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   文件上传案例的服务器端：读取本地文件，上传至服务器，读取服务器回写的数据。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   明确：</span></span><br><span class="line"><span class="comment">*       数据源：</span></span><br><span class="line"><span class="comment">*       目的地：服务器</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1.创建一个服务器ServerSocket对象，和系统要指定的端口号。</span></span><br><span class="line"><span class="comment">*       2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象。</span></span><br><span class="line"><span class="comment">*       3.使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象。</span></span><br><span class="line"><span class="comment">*       4.判断是否存在文件夹(d:\\upload)，不存在则创建。</span></span><br><span class="line"><span class="comment">*       5.创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line"><span class="comment">*       6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件。</span></span><br><span class="line"><span class="comment">*       7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上。</span></span><br><span class="line"><span class="comment">*       8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OutputStream对象。</span></span><br><span class="line"><span class="comment">*       9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”</span></span><br><span class="line"><span class="comment">*       10.释放资源(FileOutputStream,Socket,ServerSocket)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04_FileUploadServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个服务器ServerSocket对象，和系统要指定的端口号。</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   优化2 让服务器一直处于监听状态</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.使用ServerSocket对象中的方法accept，获取到请求的客户端Socket对象。</span></span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *   优化3 多线程技术，提升上传效率</span></span><br><span class="line"><span class="comment">            *   有一个文件，开一个线程，完成文件的上传。</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="comment">// 完成文件的上传</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">// 3.使用Socket中的方法getInputStream，获取网络字节输入流InputStream对象。</span></span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        <span class="comment">// 4.判断是否存在文件夹(d:\\upload)，不存在则创建。</span></span><br><span class="line">                        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\upload&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(!(file.exists())) &#123;</span><br><span class="line">                            file.mkdir();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 5.创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         *   优化1 文件名问题</span></span><br><span class="line"><span class="comment">                         *   自定义文件命名规则，防止同名的文件被覆盖。</span></span><br><span class="line"><span class="comment">                         *   规则：域名+毫秒值+随机数</span></span><br><span class="line"><span class="comment">                         * */</span></span><br><span class="line">                        String FileName = <span class="string">&quot;fan&quot;</span> + System.currentTimeMillis() + <span class="keyword">new</span> Random().nextInt(<span class="number">999999</span>) + <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">                        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file + <span class="string">&quot;\\&quot;</span> + FileName);</span><br><span class="line">                        <span class="comment">// 6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件。</span></span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> ((len = is.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// 7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上。</span></span><br><span class="line">                            fos.write(bytes);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 8.使用Socket对象中的方法getOutputStream，获取到网络字节输出流OutputStream对象。</span></span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line">                        <span class="comment">// 9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写“上传成功”</span></span><br><span class="line">                        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">                        <span class="comment">// 10.释放资源(FileOutputStream,Socket,ServerSocket)</span></span><br><span class="line">                        fos.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中网络编程相关内容。【服务器端与客户端】</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/12】23_Java_序列化流</title>
    <link href="http://example.com/2021/12/18/24_%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/"/>
    <id>http://example.com/2021/12/18/24_%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81/</id>
    <published>2021-12-18T13:55:04.606Z</published>
    <updated>2021-12-18T13:58:08.776Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a><code>ObjectOutputStream</code></h3><p>对象的<code>序列化流</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo17_ObjectStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.io.ObjectOutputStream extends OutputStream</span></span><br><span class="line"><span class="comment">*   ObjectOutputStream:对象的序列化流</span></span><br><span class="line"><span class="comment">*   作用: 把对象以流的方式写入到文件中保存。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       ObjectOutputStream(OutputStream out) 创建指定写入OutputStream的ObjectOutputStream</span></span><br><span class="line"><span class="comment">*       参数：</span></span><br><span class="line"><span class="comment">*           OutputStream out: 字节输出流</span></span><br><span class="line"><span class="comment">*       特有的成员方法：</span></span><br><span class="line"><span class="comment">*           void writeObject(Object obj) 将指定的对象写入ObjectOutputStream</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   使用步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建一个ObjectOutputStream对象，构造方法中传递字节输出流。</span></span><br><span class="line"><span class="comment">*       2. 使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中。</span></span><br><span class="line"><span class="comment">*       3. 释放资源</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_ObjectOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write_person();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_person</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个ObjectOutputStream对象，构造方法中传递字节输出流。</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo17_ObjectStream\\person.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 2. 使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中。</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;小美女&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        <span class="comment">// 3. 释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo17_ObjectStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   序列化和反序列化的时候，会抛出NotSerializableException没有序列化异常。</span></span><br><span class="line"><span class="comment">*   类通过实现java.io.Serializable接口启用序列化功能。</span></span><br><span class="line"><span class="comment">*   未实现该接口的类将无法使其任何状态序列化或反序列化。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Serializable接口称为标记接口</span></span><br><span class="line"><span class="comment">*       要实现序列化和反序列化的时候，就会检测类上是否有这个标记。</span></span><br><span class="line"><span class="comment">*       有：进行序列化和反序列化。</span></span><br><span class="line"><span class="comment">*       没有：抛出NotSerializableException没有序列化异常。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>序列化结果：</p><hr><h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a><code>ObjectInputStream</code></h3><p>对象的<code>反序列化流</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo17_ObjectStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.io.ObjectInputStream extends InputStream</span></span><br><span class="line"><span class="comment">*   ObjectInputStream:对象的反序列化流</span></span><br><span class="line"><span class="comment">*   作用：把文件中保存的对象，以流的方式读取出来并使用。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       ObjectInputStream(InputStream in) 创建从指定InputStream读取的ObjectInputStream.</span></span><br><span class="line"><span class="comment">*       参数：</span></span><br><span class="line"><span class="comment">*           InputStream in 字节输入流</span></span><br><span class="line"><span class="comment">*   特有的成员方法:</span></span><br><span class="line"><span class="comment">*       Object readObject() 从ObjectInputStream读取对象。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   使用步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建ObjectInputStream对象，构造方法中传递字节输入流。</span></span><br><span class="line"><span class="comment">*       2. 使用ObjectInputStream对象方法中的readObject读取保存对象的文件。</span></span><br><span class="line"><span class="comment">*       3. 释放资源</span></span><br><span class="line"><span class="comment">*       4. 使用读取出的对象（打印）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02_ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        person_read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">person_read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建ObjectInputStream对象，构造方法中传递字节输入流。</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo17_ObjectStream\\person.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 2. 使用ObjectInputStream对象方法中的readObject读取保存对象的文件。</span></span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   readObject方法声明抛出异常，ClassNotFoundException(class文件找不到异常)</span></span><br><span class="line"><span class="comment">        *   当不存在对象的class文件时，抛出异常。</span></span><br><span class="line"><span class="comment">        *   反序列化的前提：</span></span><br><span class="line"><span class="comment">        *       1. 类必须实现Serializable.</span></span><br><span class="line"><span class="comment">        *       2. 必须存在类对应的class文件。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="comment">// 4. 使用读取出的对象（打印）</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反序列化结果：</p><p><strong>transient关键字：瞬态关键字</strong></p><p>被序列化的都是对象。被transient修饰成员变量，不能被序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure><hr><p><code>InvalidClassException</code><strong>异常</strong></p><p><code>.java</code>文件编译成<code>.class</code>文件后，如果类进行序列化，则会生成一个序列化编号。</p><p>如果<code>.java</code>文件在编译后进行修改，则其再编译时，序列号会发生变化。再对该类进行反序列化时，会出现<code>InvalidClassException</code> 异常。（两次序列号判断不一致）</p><p><strong>解决方案：</strong></p><p>手动给类添加一个序列号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可序列化类可以通过声明名为&quot;serialVersionUID&quot;的字段，(该字段必须是静态的(static)、最终的(final)的long型字段)显式声明其自己的serialVersionUID</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> seriaVersionUID = <span class="number">42L</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中IO流操作相关知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/11】22_Java_缓冲流与转换流</title>
    <link href="http://example.com/2021/12/18/23_%E7%BC%93%E5%86%B2%E6%B5%81%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%B5%81/"/>
    <id>http://example.com/2021/12/18/23_%E7%BC%93%E5%86%B2%E6%B5%81%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%B5%81/</id>
    <published>2021-12-18T13:51:07.840Z</published>
    <updated>2021-12-18T13:54:33.256Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="缓冲流和转换流"><a href="#缓冲流和转换流" class="headerlink" title="缓冲流和转换流"></a>缓冲流和转换流</h2><h3 id="缓冲流-Buffered"><a href="#缓冲流-Buffered" class="headerlink" title="缓冲流[Buffered]"></a>缓冲流[Buffered]</h3><p>给基本的字节输入流增加一个缓冲区(数组)提高基本的字节输入流的读取效率。</p><p><code>BufferedInputStream(new FileInputStream())</code></p><h4 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a><code>BufferedInputStream</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo15_Buffered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   java.io.BufferedInputStream extends InputStream</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   继承自父类的方法：</span></span><br><span class="line"><span class="comment"> *       int read() 从输入流中读取数据的下一个字节。</span></span><br><span class="line"><span class="comment"> *       int read(byte[] b) 从输入流中读取一定数量的字节，并存储在缓冲区数组b中。</span></span><br><span class="line"><span class="comment"> *       void close() 关闭此输入流并释放与该流关联的所有系统资源。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   构造方法：</span></span><br><span class="line"><span class="comment"> *       BufferedOutputStream(InputStream in) 创建一个BufferedOutputStream并保存参数即输入流in，供将来使用。</span></span><br><span class="line"><span class="comment"> *       BufferedOutputStream(InputStream in, int size)创建一个指定缓冲区大小的BufferedOutputStream并保存参数即输入流in，供将来使用。</span></span><br><span class="line"><span class="comment"> *       参数：读取文件的数据源。</span></span><br><span class="line"><span class="comment"> *           InputStream in:字节输入流。</span></span><br><span class="line"><span class="comment"> *           int size: 指定缓冲流内部缓冲n区的大小，不指定则默认。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   使用步骤(重点)：</span></span><br><span class="line"><span class="comment"> *       1.创建一个FileInputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line"><span class="comment"> *       2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象对象，提高FileInputStream对象读取效率。</span></span><br><span class="line"><span class="comment"> *       3.使用BufferedInputStream对象中的方法read,读取文件。</span></span><br><span class="line"><span class="comment"> *       4.释放资源(会先调用flush方法刷新数据，则第四步可省略)</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02BufferedInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo15_Buffered\\a.txt&quot;</span>);</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while ((len = bis.read())!= -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len2 = fis.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a><code>BufferedOutputStream</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo15_Buffered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.io.BufferedOutputStream extends OutputStream</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   继承自父类的共性成员方法:</span></span><br><span class="line"><span class="comment">*       - public void close(): 关闭该输出流并释放与该流相关联的任何系统资源。</span></span><br><span class="line"><span class="comment">*       - public void flush(): 刷新此输出流，并强制任何缓冲的输出字节被写出。</span></span><br><span class="line"><span class="comment">*       - public void write(byte[] b): 将b.length字节从指定的字节数组写入此输出流。</span></span><br><span class="line"><span class="comment">*       - public void write(byte[] b, int off, int len): 从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。</span></span><br><span class="line"><span class="comment">*       - public abstract void write(int b): 将指定的字节输出流。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</span></span><br><span class="line"><span class="comment">*       BufferedOutputStream(OutputStream out, int size)创建一个新的缓冲输出流，以将指定缓冲区大小的数据写入指定的底层输出流。</span></span><br><span class="line"><span class="comment">*       参数：写入的目的地。</span></span><br><span class="line"><span class="comment">*               OutputStream out: 字节输出流。</span></span><br><span class="line"><span class="comment">*               int size: 指定缓冲流内部缓冲区的大小，不指定则默认。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   使用步骤(重点)：</span></span><br><span class="line"><span class="comment">*       1.创建一个FileOutputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line"><span class="comment">*       2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象对象，提高FileOutputStream对象效率</span></span><br><span class="line"><span class="comment">*       3.使用BufferedOutputStream对象中的方法write,将数据写入到内部缓冲区中。</span></span><br><span class="line"><span class="comment">*       4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据，刷新到文件中。</span></span><br><span class="line"><span class="comment">*       5.释放资源(会先调用flush方法刷新数据，则第四步可省略)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01BufferedOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建一个BufferedOutputStream对象，构造方法中绑定要输出的目的地。</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo15_Buffered\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象对象，提高FileOutputStream对象效率</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">// 3.使用BufferedOutputStream对象中的方法write,将数据写入到内部缓冲区中。</span></span><br><span class="line">        bos.write(<span class="string">&quot;写入数据&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据，刷新到文件中。</span></span><br><span class="line">        bos.flush();</span><br><span class="line">        <span class="comment">// 5.释放资源(会先调用flush方法刷新数据，则第四步可省略)</span></span><br><span class="line">        bos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title=" BufferedReader"></a><code> BufferedReader</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo15_Buffered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*    java.io.BufferedReader extends Reader</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    继承自父类的方法：</span></span><br><span class="line"><span class="comment">*       int read() 读取单个字符并返回</span></span><br><span class="line"><span class="comment">*       int read(char[] cbuf) 一次读取多个字符，将字符读取数组。</span></span><br><span class="line"><span class="comment">*       void close() 关闭该流并释放与之相关的所有资源。</span></span><br><span class="line"><span class="comment">*    构造方法：</span></span><br><span class="line"><span class="comment">*       BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。</span></span><br><span class="line"><span class="comment">*       BufferedReader(Reader in， int sz) 创建一个使用指定大小输入缓冲区的缓冲字符输入流。</span></span><br><span class="line"><span class="comment">*   参数：</span></span><br><span class="line"><span class="comment">*       Reader in 字符输入流</span></span><br><span class="line"><span class="comment">*           可以传递给FileReader,缓冲流会给FileReader增加一个缓冲区，提高FileReader的读取效率。</span></span><br><span class="line"><span class="comment">*   特有的成员方法：</span></span><br><span class="line"><span class="comment">*       String readLine() 读取一个文本行。读取一行数据。</span></span><br><span class="line"><span class="comment">*           行的终止符号：通过以下字符之一即可认为某行已经终止。换行(&#x27;\n&#x27;)、回车(&#x27;\r&#x27;)或者回车之后直接接着换行(\r\n).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04BufferedReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo15_Buffered\\buf.txt&quot;</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a><code>BufferedWriter</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo15_Buffered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.io.BufferedWriter extends Writer</span></span><br><span class="line"><span class="comment">*   BufferedWriter: 字符缓冲输出流</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   共性的方法：</span></span><br><span class="line"><span class="comment">*       - void write(int c) 写入单个字符。</span></span><br><span class="line"><span class="comment">*       - void write(char[] cbuf)写入字符数组</span></span><br><span class="line"><span class="comment">*       - abstract void write(char[] cbuf, int off, int len)写入字符数组的一部分，off是数组的开始索引，len写的是字符个数</span></span><br><span class="line"><span class="comment">*       - void write(String str)写入字符串</span></span><br><span class="line"><span class="comment">*       - void write(String str, int off, int len)写入字符串的某一部分，off字符串的开始索引，len写的字符个数</span></span><br><span class="line"><span class="comment">*       - void flush()刷新该流的缓冲</span></span><br><span class="line"><span class="comment">*       - void close()关闭该流，但是要先刷新它</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       BufferedWriter(Writer out) 创建一个使用默认大小缓冲区的缓冲字符输出流。</span></span><br><span class="line"><span class="comment">*       BufferedWriter(Writer out, int sz) 创建一个使用给定大小缓冲区的新缓冲字符输出流。</span></span><br><span class="line"><span class="comment">*   特有的成员方法：</span></span><br><span class="line"><span class="comment">*       void newLine() 写入一个行分隔符。会根据操作系统获取不同的行分隔符。</span></span><br><span class="line"><span class="comment">*       换行：换行符号</span></span><br><span class="line"><span class="comment">*       windows: \r\n</span></span><br><span class="line"><span class="comment">*       linux:/n</span></span><br><span class="line"><span class="comment">*       mac:/r</span></span><br><span class="line"><span class="comment">*   使用步骤:</span></span><br><span class="line"><span class="comment">*       1.创建字符缓冲输出流对象，构造方法中传递字符输出流。</span></span><br><span class="line"><span class="comment">*       2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中。</span></span><br><span class="line"><span class="comment">*       3.调用flush，将内存缓冲区中的数据刷新到文件。</span></span><br><span class="line"><span class="comment">*       4.释放资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03BufferedWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建字符缓冲输出流对象，构造方法中传递字符输出流。</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo15_Buffered\\buf.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            bw.write(<span class="string">&quot;这是一个测试&quot;</span>);</span><br><span class="line"><span class="comment">//            bw.write(&quot;\r\n&quot;);</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调用flush，将内存缓冲区中的数据刷新到文件。</span></span><br><span class="line">        bw.flush();</span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p><code>java.io.InputStreamReader</code> 是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用<strong>指定的字符集</strong>将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><p><code>java.io.OutputStreamWriter</code> 是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。读取字符，并使用指定得字符集将其解码为字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo16_ReverseStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.io.OutputStreamWriter extends Writer</span></span><br><span class="line"><span class="comment">*   OutputStreamWriter: 字符流通向字节流的桥梁，可以使用指定得charset将要写入流中的字符编码成字节。(编码：把看得懂的转化成看不懂的)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   继承来自父类的共性成员方法：</span></span><br><span class="line"><span class="comment">*       - void write(int c) 写入单个字符。</span></span><br><span class="line"><span class="comment">*       - void write(char[] cbuf)写入字符数组</span></span><br><span class="line"><span class="comment">*       - abstract void write(char[] cbuf, int off, int len)写入字符数组的一部分，off是数组的开始索引，len写的是字符个数</span></span><br><span class="line"><span class="comment">*       - void write(String str)写入字符串</span></span><br><span class="line"><span class="comment">*       - void write(String str, int off, int len)写入字符串的某一部分，off字符串的开始索引，len写的字符个数</span></span><br><span class="line"><span class="comment">*       - void flush()刷新该流的缓冲</span></span><br><span class="line"><span class="comment">*       - void close()关闭该流，但是要先刷新它</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   构造方法：</span></span><br><span class="line"><span class="comment">*       OutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter</span></span><br><span class="line"><span class="comment">*       OutputStreamWriter(OutputStream out， String charsetName) 创建使用指定字符集的OutputStreamWriter.默认UTF-8</span></span><br><span class="line"><span class="comment">*       参数：</span></span><br><span class="line"><span class="comment">*           OutputStream out: 字节输出流，可以用来写转换之后的字节到文件中。</span></span><br><span class="line"><span class="comment">*           String charsetName: 指定编码表名称，不区分大小写。</span></span><br><span class="line"><span class="comment">*   使用步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称。</span></span><br><span class="line"><span class="comment">*       2. 使用OutputStreamWriter对象中的方法write，把字符转换成字节存储在缓冲区中。</span></span><br><span class="line"><span class="comment">*       3. 使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中。(使用字节流写字节的过程)</span></span><br><span class="line"><span class="comment">*       4. 释放资源</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01OutputStreamWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write_utf_8();</span><br><span class="line">        write_gbk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_gbk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称。</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo16_ReverseStream\\gbk.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 使用OutputStreamWriter对象中的方法write，把字符转换成字节存储在缓冲区中。</span></span><br><span class="line">        osw.write(<span class="string">&quot;你好呀&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中。(使用字节流写字节的过程)</span></span><br><span class="line">        osw.flush();</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_utf_8</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称。</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo16_ReverseStream\\utf_8.txt&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 使用OutputStreamWriter对象中的方法write，把字符转换成字节存储在缓冲区中。</span></span><br><span class="line">        osw.write(<span class="string">&quot;你好呀&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中。(使用字节流写字节的过程)</span></span><br><span class="line">        osw.flush();</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中缓冲流(Buffered)和转换流(InputStrea/OutputStream)相关知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/10】21_Java_Properties</title>
    <link href="http://example.com/2021/12/18/22_Properties/"/>
    <id>http://example.com/2021/12/18/22_Properties/</id>
    <published>2021-12-18T13:47:12.506Z</published>
    <updated>2021-12-18T13:50:51.792Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Properties属性类"><a href="#Properties属性类" class="headerlink" title="Properties属性类"></a>Properties属性类</h2><h3 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;</span></span><br><span class="line"><span class="comment">*   Properties类表示一个持久的属性集。Properties 可保存在流中，或从流中加载。</span></span><br><span class="line"><span class="comment">*   Properties集合是一个唯一和IO流相结合的集合。</span></span><br><span class="line"><span class="comment">*       (1)store方法，把集合中的临时数据，持久化写入到硬盘存储。</span></span><br><span class="line"><span class="comment">*       (2)load方法，把硬盘中保存的文件(键值对)，读取到集合中使用。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   属性列表中每个键与其对应值都是一个字符串。</span></span><br><span class="line"><span class="comment">*       Properties集合是一个双列集合，key和value默认为字符串。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p><code>store</code>方法的Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建Properties集合对象，添加数据</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;182&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;160&quot;</span>);</span><br><span class="line">    prop.setProperty(<span class="string">&quot;Golang&quot;</span>,<span class="string">&quot;175&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建字节输出流/字符输出流，构造方法中绑定要输出的目的地。</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo14_Properties\\prop.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储</span></span><br><span class="line">    <span class="comment">// 字符流可以写中文，字节流不能写中文。</span></span><br><span class="line">    prop.store(fw,<span class="string">&quot;Sava Data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 释放资源</span></span><br><span class="line">    fw.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>load</code>方法的Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show03</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用</span></span><br><span class="line"><span class="comment">    *   void load(InputStream inStream)</span></span><br><span class="line"><span class="comment">    *   void load(Reader reader)</span></span><br><span class="line"><span class="comment">    *   参数：</span></span><br><span class="line"><span class="comment">    *       InputStream inStream:字节输入流，不能读取含有中文的键值对</span></span><br><span class="line"><span class="comment">    *       Reader reader：字符输入流，可以读取含有中文的键值对。</span></span><br><span class="line"><span class="comment">    *   使用步骤：</span></span><br><span class="line"><span class="comment">    *       1.创建Properties集合对象。</span></span><br><span class="line"><span class="comment">    *       2.使用Properties集合对象中的方法load读取保存键值对的文件.</span></span><br><span class="line"><span class="comment">    *       3.遍历Properties集合</span></span><br><span class="line"><span class="comment">    *   注意：</span></span><br><span class="line"><span class="comment">    *       1.存储键值对的文件中，键与值默认的连接符号可以是=，空格（其他符号）</span></span><br><span class="line"><span class="comment">    *       2.存储键值对的文件中，可以使用#进行注释，被注释的键值对不会被读取</span></span><br><span class="line"><span class="comment">    *       3.存在键值对的文件中，键与值默认都是字符串，不用再加引号。</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;G:\\1_JAVA\\java\\demo\\basic-code\\day1-code\\src\\com\\fanpeng\\day06\\Demo14_Properties\\prop.txt&quot;</span>));</span><br><span class="line">    Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">    <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">        String value = prop.getProperty(key);</span><br><span class="line">        System.out.println(key + <span class="string">&#x27;=&#x27;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中Properties属性类相关知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/08】19_Java_File</title>
    <link href="http://example.com/2021/12/18/19_File%E7%B1%BB/"/>
    <id>http://example.com/2021/12/18/19_File%E7%B1%BB/</id>
    <published>2021-12-18T13:30:41.581Z</published>
    <updated>2021-12-18T13:42:25.688Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p><code>java.io.File</code>类：主要用于文件和目录的创建、查找和删除等操作。</p><hr><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>(1) 绝对路径: 完整的路径。</p><p>​    以盘符(c:, D:)开始的路径。</p><p>(2) 相对路径: 简化的路径。</p><p>​    相对指的是相对于当前项目的根目录。如果使用当前项目的根目录，可以简化书写。</p><p>注意：</p><ol><li>路径不区分大小写。</li><li>路径中的文件名称分隔符windows使用反斜杠，反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠。</li></ol><hr><h3 id="File类的方法"><a href="#File类的方法" class="headerlink" title="File类的方法"></a>File类的方法</h3><h4 id="File类获取功能的方法"><a href="#File类获取功能的方法" class="headerlink" title="File类获取功能的方法"></a>File类获取功能的方法</h4><p><code>public String getAbsolutePath()</code>: 返回此File的绝对路径名字符串</p><p><code>public String getPath()</code>: 将此File转换为路径名字符串</p><p><code>public String getName()</code>: 返回此文件或是目录的名称</p><p><code>public long length()</code>: 返回由此File表示的文件的大小(以字节为单位)。如果路径文件不存在，length方法返回的是0.</p><h4 id="File类判断功能的方法："><a href="#File类判断功能的方法：" class="headerlink" title="File类判断功能的方法："></a>File类判断功能的方法：</h4><p><code>public boolean exists()</code>: 此File表示的文件或目录是否实际存在</p><p><code>public boolean isDirectory()</code>: 此File表示的是否是目录</p><p><code>public boolean isFile()</code>: 此File表示的是否是文件</p><h4 id="File类创建删除功能的方法："><a href="#File类创建删除功能的方法：" class="headerlink" title="File类创建删除功能的方法："></a>File类创建删除功能的方法：</h4><p><code>public boolean createNewFile()</code>: 当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</p><p><code>public boolean delete()</code>: 删除由此File表示的文件或目录。文件夹中有内容，不删除返回false。</p><p><code>public boolean mkdir()</code>: 创建由此File表示的目录，只能创建单级文件夹。</p><p><code>public boolean mkdirs()</code>: 创建由此File表示的目录，包括任何必需但不存在的父目录。可创建单级，也可创建多级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. 创建文件/文件夹的路径一定要是存在的，否则会抛出异常。</span></span><br><span class="line"><span class="comment">*       2. 文件/文件夹不存在，创建文件/文件夹，返回true.</span></span><br><span class="line"><span class="comment">*       3. 文件/文件夹存在，不创建，返回false.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="File类遍历-文件夹-目录功能："><a href="#File类遍历-文件夹-目录功能：" class="headerlink" title="File类遍历(文件夹)目录功能："></a>File类遍历(文件夹)目录功能：</h4><p><code>public String[] list()</code>:</p><p>(1) 返回一个String数组，表示该file目录中的所有子文件或目录。</p><p>(2) 返回String数组。</p><p>(3) 遍历构造方法中给出的目录，会获取目录中所有文件/文件夹名称，然后存入到一个String类型的数组中。</p><p><code>public File[] listFile()</code>: </p><p>(1) 返回一个File数组，表示该File目录中的所有子文件或目录。</p><p>(2) 返回一个File数组。</p><p>(3) 遍历构造方法中给出的目录，会获取目录中所有文件/文件夹名称，然后封装为File对象，多个File对象存储到File数组中。</p><hr>]]></content>
    
    
    <summary type="html">Java中File类知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/08】18_Java_Lambda(函数式编程)</title>
    <link href="http://example.com/2021/12/18/18_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/12/18/18_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-12-18T13:28:53.866Z</published>
    <updated>2021-12-18T13:30:34.064Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h4><p>(1) 面向对象的思想：强调“必须通过对线的形式来做事情”。做一件事情，找一个能解决这个事情的对象，调用这个对象的方法，完成事情。</p><p>(2) 函数式编程的思想：只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程。</p><hr><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>用简单的代码编写方式实现程序功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo10_Lambda;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Lambda表达式的标准格式：</span></span><br><span class="line"><span class="comment">*       由三部分组成：</span></span><br><span class="line"><span class="comment">*           (1)一些参数</span></span><br><span class="line"><span class="comment">*           (2)一个箭头</span></span><br><span class="line"><span class="comment">*           (3)一段代码</span></span><br><span class="line"><span class="comment">*       格式：</span></span><br><span class="line"><span class="comment">*           (参数列表) -&gt; &#123;一些重写方法的代码&#125;;</span></span><br><span class="line"><span class="comment">*       解释：</span></span><br><span class="line"><span class="comment">*           ():接口中抽象方法的参数列表，没有参数就空着；有参数就写出参数，多个参数用逗号隔开。</span></span><br><span class="line"><span class="comment">*           -&gt;:传递的意思，将参数传递给方法体。</span></span><br><span class="line"><span class="comment">*           &#123;&#125;:重写接口的抽象方法的方法体。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被创建！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式实现相同的功能</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被创建！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo10_Lambda;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数无返回值的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02_LambdaParameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用数组存储多个Person对象</span></span><br><span class="line">        Person[] arr = &#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Wolf&quot;</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Skin&quot;</span>,<span class="number">37</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组中的成员通过年龄大小进行排序</span></span><br><span class="line"><span class="comment">//        Arrays.sort(arr, new Comparator&lt;Person&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Person o1, Person o2) &#123;</span></span><br><span class="line"><span class="comment">//                return o1.getAge()-o2.getAge();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式</span></span><br><span class="line">        Arrays.sort(arr, (Person o1,Person o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优化Lambda表达式(参数类型 return 大括号一同省略)</span></span><br><span class="line">        Arrays.sort(arr, (o1,o2) -&gt; o1.getAge()-o2.getAge());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : arr) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Lambda使用前提</strong></p><ol><li>Lambda必须有接口，并且要求接口中<strong>有且仅有一个抽象方法</strong>。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。</li></ol><hr>]]></content>
    
    
    <summary type="html">Java中函数式编程知识点。(Lambda)</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/07】17_Java_Thread</title>
    <link href="http://example.com/2021/12/18/17_%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/12/18/17_%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-12-18T13:15:29.461Z</published>
    <updated>2021-12-18T13:28:01.230Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：指两个或多个事件在同一时间段内发生。</p><p>【单CPU】</p><p>并行：指两个或多个事件在同一时刻发生。(同时发生) — 速度快</p><p>【多CPU】</p><hr><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p><strong>进程</strong>：进入到内存中的程序。</p><p>内存：所有的应用程序都需要进入到内存中才能执行，临时存储RAM。</p><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行。一个进程至少有一个线程。一个进程中可以有多个线程，这个应用称为多线程。</p><p>CPU：中央处理器，对数据进行计算，指挥电脑中的软件和硬件干活。</p><p>线程属于进程，是进程中的一个执行单元，负责程序的执行。</p><p><strong>线程调度</strong>：</p><ol><li>分时调度：所有线程轮流使用CPU。</li><li>抢占式调度：按照优先级，分配CPU。</li></ol><p><strong>主线程</strong></p><p>执行主方法(main)的线程。</p><p>单线程程序：Java程序中只有一个线程。执行从main方法开始，从上到下依次执行。</p><p><strong>JVM执行main方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   JVM执行main方法，main方法会进入到栈内存。</span></span><br><span class="line"><span class="comment">*   JVM会找操作系统开辟一条main方法通向cpu的执行路径。</span></span><br><span class="line"><span class="comment">*   cpu就可以通过这个路径执行main方法。</span></span><br><span class="line"><span class="comment">*   这个路径的名字就叫主线程。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><hr><h4 id="创建多线程的方法"><a href="#创建多线程的方法" class="headerlink" title="创建多线程的方法"></a>创建多线程的方法</h4><p>方法1：<code>Thread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   创建多线程的方法1：创建Thread类的子类。</span></span><br><span class="line"><span class="comment">*   java.lang.Thread类：描述线程的类，想要实现多线程程序，必须继承Thread类。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建一个Thread类的子类对象。</span></span><br><span class="line"><span class="comment">*       2. 在Thread类的子类中重写Thread类的run方法，设置线程任务。</span></span><br><span class="line"><span class="comment">*       3. 创建Thread类的子类对象。</span></span><br><span class="line"><span class="comment">*       4. 调用Thread类中的方法start，开启新的线程，执行run方法。</span></span><br><span class="line"><span class="comment">*           void strat() 使得该线程开始执行; JVM调用线程的run方法。</span></span><br><span class="line"><span class="comment">*           结果：两个线程并发执行。</span></span><br><span class="line"><span class="comment">*   java程序属于抢占式调度，哪个线程优先级高，先执行哪个线程；同一优先级，随机执行。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建Thread类的子类对象。</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 4. 调用Thread类中的方法start，开启新的线程，执行run方法。</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyThread.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个Thread类的子类对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2. 在Thread类的子类中重写Thread类的run方法，设置线程任务。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：<code>Runnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo05Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   创建多线程的第二种方式：实现Runnable接口。</span></span><br><span class="line"><span class="comment">*   java.lang.Runnable</span></span><br><span class="line"><span class="comment">*           Runnable接口应当由打算通过某一线程执行其实例的类来实现。类必须定义一个run的无参构造方法。</span></span><br><span class="line"><span class="comment">*   java.lang.Thread类的构造方法：</span></span><br><span class="line"><span class="comment">*           Thread(Runnable target) 分配新的Thread对象。</span></span><br><span class="line"><span class="comment">*           Thread(Runnable target, String name) 分配新的Thread对象。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1. 创建一个Runnable接口的实现类。</span></span><br><span class="line"><span class="comment">*       2. 在实现类中重写Runnable接口的run方法，设置线程任务。</span></span><br><span class="line"><span class="comment">*       3. 创建一个Runnable接口的实现类对象。</span></span><br><span class="line"><span class="comment">*       4. 创建Thread类对象，构造方法中传递Runnable接口的实现类对象。</span></span><br><span class="line"><span class="comment">*       5. 调用Thread类中的start方法，开启新线程执行run方法。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   实现Runnable接口创建多线程程序的好处：</span></span><br><span class="line"><span class="comment">*       1. 避免了单继承的局限性</span></span><br><span class="line"><span class="comment">*           一个类只能继承一个类，类继承了Thread就不能再继承别的类。</span></span><br><span class="line"><span class="comment">*           实现了Runnable接口，还可以继承其他的类，实现了其他的接口。</span></span><br><span class="line"><span class="comment">*       2. 增强了程序的扩展性，降低了程序的耦合性。</span></span><br><span class="line"><span class="comment">*           实现Runnable接口的方式，把设置线程的任务与开始新线程进行分离(解耦)。</span></span><br><span class="line"><span class="comment">*           实现类中，重写了run方法：用来设置线程任务。</span></span><br><span class="line"><span class="comment">*           创建Thread类对象，调用start方法：用来开启新线程。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 创建一个Runnable接口的实现类对象。</span></span><br><span class="line">        MyThread01 run = <span class="keyword">new</span> MyThread01();</span><br><span class="line">        <span class="comment">// 4. 创建Thread类对象，构造方法中传递Runnable接口的实现类对象。</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        <span class="comment">// 5. 调用Thread类中的start方法，开启新线程执行run方法。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>MyThread01.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo05Thread;</span><br><span class="line"><span class="comment">// 1. 创建一个Runnable接口的实现类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread01</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2. 在实现类中重写Runnable接口的run方法，设置线程任务。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名内部类实现线程的创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo05Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   匿名内部类方式实现线程的创建。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   匿名：没有名字</span></span><br><span class="line"><span class="comment">*   内部类：写在其他类内部的类。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   匿名内部类作用：简化代码</span></span><br><span class="line"><span class="comment">*       把子类继承父类，重写父类的方法，创建子类对象一步完成。</span></span><br><span class="line"><span class="comment">*       把实现类实现类接口，重写接口中的方法，创建实现类对象一步完成。</span></span><br><span class="line"><span class="comment">*   匿名内部类的产物：子类/实现类对象，而这个类没有名字。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   格式：</span></span><br><span class="line"><span class="comment">*       new 父类/接口()&#123;</span></span><br><span class="line"><span class="comment">*           重复父类/接口中的方法</span></span><br><span class="line"><span class="comment">*       &#125;;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04InnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程的父类Thread</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">// 重写run方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类调试&quot;</span>+<span class="string">&quot;---&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程的接口Runnable</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类调试2&quot;</span>+<span class="string">&quot;---&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再简化</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类调试3&quot;</span>+<span class="string">&quot;---&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多线程访问了共享的数据，会产生线程安全问题。</p><h4 id="解决线程安全—同步机制"><a href="#解决线程安全—同步机制" class="headerlink" title="解决线程安全—同步机制"></a>解决线程安全—同步机制</h4><p>三种方式：</p><ol><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   解决线程安全问题的一种方法：使用同步代码块。</span></span><br><span class="line"><span class="comment">*   格式：</span></span><br><span class="line"><span class="comment">*       synchronized(锁对象) &#123;</span></span><br><span class="line"><span class="comment">*           可能出现线程安全问题的代码。</span></span><br><span class="line"><span class="comment">*       &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. 通过代码块中的锁对象，可以使用任意的对象。</span></span><br><span class="line"><span class="comment">*       2. 必须保证多个线程使用的锁对象唯一。</span></span><br><span class="line"><span class="comment">*       3. 锁对象的作用：把同步代码块锁住，只有一个线程在同步代码中执行。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 创建一个锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环卖票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// ------------------同步代码块------------------------</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="comment">// 判断是否有余票</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 存在票，ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li><li><p>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决线程安全问题的第二个方法：定义一个同步方法，同步方法也会把方法内部的代码锁住。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   使用步骤:</span></span><br><span class="line"><span class="comment">*       1. 把访问了共享数据的代码抽取出来，放到方法中。</span></span><br><span class="line"><span class="comment">*       2. 在方法上添加synchronized修饰符。</span></span><br><span class="line"><span class="comment">*   格式：</span></span><br><span class="line"><span class="comment">*   修饰符 synchronized 返回值类型 方法名(参数列表) &#123; //方法体&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有余票</span></span><br><span class="line">    <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 存在票，ticket--</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        ticket--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>锁机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   解决线程安全问题的三种方法：使用锁机制(Lock锁)。</span></span><br><span class="line"><span class="comment">*   Lock锁提供了比synchronized方法和语句可获得的更广泛的锁定操作。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Lock锁中的方法：</span></span><br><span class="line"><span class="comment">*       void lock()获取锁</span></span><br><span class="line"><span class="comment">*       void unlock()释放锁</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   使用步骤：</span></span><br><span class="line"><span class="comment">*       1. 在成员位置创建一个ReentrantLock对象。</span></span><br><span class="line"><span class="comment">*       2. 在可能发生线程安全问题的代码前调用Lock接口中的方法lock()获取锁。</span></span><br><span class="line"><span class="comment">*       3. 在可能发生线程安全问题的代码后调用Lock接口中的方法unlock()释放锁。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 1. 在成员位置创建一个ReentrantLock对象。</span></span><br><span class="line">    Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环卖票</span></span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 2. 在可能发生线程安全问题的代码前调用Lock接口中的方法lock()获取锁。</span></span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    <span class="comment">// 存在票，ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 在可能发生线程安全问题的代码后调用Lock接口中的方法unlock()释放锁。</span></span><br><span class="line">                    l.unlock(); <span class="comment">// 无论是否出现异常，都会将锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>同步技术的原理</strong>：</p><p>使用一个锁对象，也叫同步锁、对象锁，或是对象监视器。</p><p><strong>同步中的线程，没有执行完毕不会释放锁，同步外的线程没有锁进不去同步。</strong></p><p>同步保证只有一个线程在同步中执行共享数据，保证安全。但是频繁的判断锁，获取锁，释放锁，程序的效率会降低。</p><hr><h4 id="等待唤醒-wait-＆-notify"><a href="#等待唤醒-wait-＆-notify" class="headerlink" title="等待唤醒(wait ＆ notify)"></a>等待唤醒(wait ＆ notify)</h4><p>线程之间的通信。有效的利用资源。</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   等待唤醒案例：</span></span><br><span class="line"><span class="comment">*       顾客：创建一个消费者线程，调用wait方法，放弃cpu的执行，进入到Waiting状态(无限等待)。</span></span><br><span class="line"><span class="comment">*       商家：创建一个商家线程，完成顾客的需求之后，调用notify方法，唤醒顾客。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       顾客和商家线程必须使用同步代码块包裹起来，保证等待和唤醒只有一个在执行。</span></span><br><span class="line"><span class="comment">*       同步使用的锁对象必须是保证唯一。</span></span><br><span class="line"><span class="comment">*       只有锁对象才能调用wait和notify方法。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Object中的类：</span></span><br><span class="line"><span class="comment">*       void wait():在其他线程调用此对象的notify()方法或notifyAll()方法前，导致当前的线程等待。</span></span><br><span class="line"><span class="comment">*       void notify():唤醒此对象监视器上等待的某个线程，会继续执行wait方法后面的代码。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建锁对象，保证唯一。</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个顾客的线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客开始点餐&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// wait之后的执行的动作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;开吃！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">// 创建一个商家线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;餐已做好！拿给顾客！&quot;</span>);</span><br><span class="line">                    obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用wait和notify方法时，需要注意的点:</strong></p><ol><li><p>wait方法和notify方法必须要由<strong>同一个锁对象</strong>调用。</p><p>对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</p></li><li><p>wait和notify方法是属于<strong>Object类</strong>的方法。</p><p>锁对象可以是任意类对象。所有类都是继承自Object类。</p></li><li><p>wait方法和notify方法必须要在同步代码块或是<strong>同步函数</strong>中使用。</p><p>必须要通过锁对象调用两个方法。</p></li></ol><hr><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>容器：集合(<code>ArrayList</code>,<code>HashSet</code>,<code>LinkedList&lt;Thread&gt;</code>,<code>HashMap</code>)</p><p>容纳多个线程的容器，其中的线程可以反复使用，无需反复创建线程耗费资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo09_ThreadPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   线程池</span></span><br><span class="line"><span class="comment">*   import java.util.concurrent.Executor;线程池的工厂类，用来生成线程池。</span></span><br><span class="line"><span class="comment">*   Executor类中的静态方法：</span></span><br><span class="line"><span class="comment">*       static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment">*       创建一个可重用固定线程数的线程池</span></span><br><span class="line"><span class="comment">*       参数：int nThreads 创建线程池中包含的线程数</span></span><br><span class="line"><span class="comment">*       返回值：ExecutorService接口，是ExecutorService接口的实现类对象，可以使用ExecutorService接口接收。(面象接口编程)</span></span><br><span class="line"><span class="comment">*   java.util.concurrent.ExecutorService:线程池接口</span></span><br><span class="line"><span class="comment">*       用来从线程池中获取线程，调用start方法，执行线程任务。</span></span><br><span class="line"><span class="comment">*           submit(Runnable task)提交一个Runnable任务用于执行。</span></span><br><span class="line"><span class="comment">*       关闭/销毁线程池：</span></span><br><span class="line"><span class="comment">*           void shutdown()</span></span><br><span class="line"><span class="comment">*   线程池的使用步骤:</span></span><br><span class="line"><span class="comment">*       1. 使用线程池的工厂类Executor里提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</span></span><br><span class="line"><span class="comment">*       2. 创建一个类，实现Runnable接口，重写run方法，设置线程任务。</span></span><br><span class="line"><span class="comment">*       3. 调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。</span></span><br><span class="line"><span class="comment">*       4. 调用ExecutorService中的方法shutdown销毁线程池。(不建议使用)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 使用线程池的工厂类Executor里提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 3. 调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法。</span></span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">        es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池(一般不用)</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunnableImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo09_ThreadPool;</span><br><span class="line"><span class="comment">// 2. 创建一个类，实现Runnable接口，重写run方法，设置线程任务。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在执行任务！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中线程知识点。(并发与并行、线程与进程、同步技术、线程池...)</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/02】16_Java_Exception</title>
    <link href="http://example.com/2021/12/18/16_%E5%BC%82%E5%B8%B8/"/>
    <id>http://example.com/2021/12/18/16_%E5%BC%82%E5%B8%B8/</id>
    <published>2021-12-18T13:08:36.924Z</published>
    <updated>2021-12-18T13:11:59.431Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Java中异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象。</p><p>Java处理异常的方式是中断处理。</p><p>程序在执行过程中，出现的非正常的情况，最终导致JVM的非正常停止。</p><hr><h4 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h4><p>在指定的方法里面抛出指定的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo04_Exception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   throw关键字</span></span><br><span class="line"><span class="comment">*   作用: 可以使用throw关键字在指定的方法中抛出异常。</span></span><br><span class="line"><span class="comment">*   使用格式：throw new xxxException(&quot;异常产生的原因&quot;);</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. throw关键字必须写在方法的内部。</span></span><br><span class="line"><span class="comment">*       2. throw关键字后面new的对象必须是Exception或者Exception的子类对象。</span></span><br><span class="line"><span class="comment">*       3. throw关键字抛出指定的异常对象，我们就必须处理这个异常对象。</span></span><br><span class="line"><span class="comment">*           throw关键字后面创建的是RuntimeException或者是RuntimeException的子类对象，我们可以不处理，默认交给JVM处理。</span></span><br><span class="line"><span class="comment">*           throw关键字后面创建的是编译异常(写代码时报错),我们就必须处理这个异常，要么throws,要么try...catch。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Throw</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(getElement(a,<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   首先必须对方法传递过来的参数进行合法性校验。</span></span><br><span class="line"><span class="comment">    *   如果传递的参数有问题，要使用抛出异常的方式，告知传递的参数有问题。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   定义空指针异常。</span></span><br><span class="line"><span class="comment">        *   如果传递的数组arr是null，就会报错&quot;传递的数组是空的！&quot;</span></span><br><span class="line"><span class="comment">        *   NullPointerException：是一个运行期异常。默认交给JVM处理。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;传递的数组是空的！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   定义数组索引越界异常。</span></span><br><span class="line"><span class="comment">        *   如果传递的数组索引不在范围之内，则抛出越界异常</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index &gt;arr.length-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;传递的索引越界！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ele = arr[index];</span><br><span class="line">        <span class="keyword">return</span> ele;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   throws关键字：异常处理的第一种方式，交给别人处理。</span></span><br><span class="line"><span class="comment">*   作用：</span></span><br><span class="line"><span class="comment">*       当方法内部抛出异常对象的时候，必须要处理这个异常对象。</span></span><br><span class="line"><span class="comment">*       可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理(自己不处理)，最终交给JVM处理--&gt;中断处理</span></span><br><span class="line"><span class="comment">*   使用格式：</span></span><br><span class="line"><span class="comment">*       修饰符 返回值类型 方法名(参数列表) throws AAAException,BBBException...&#123;</span></span><br><span class="line"><span class="comment">*           throw new AAAException(&quot;产生原因&quot;);</span></span><br><span class="line"><span class="comment">*           throw new BBBException(&quot;产生原因&quot;);</span></span><br><span class="line"><span class="comment">*           ...</span></span><br><span class="line"><span class="comment">*       &#125;</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. throws关键字必须写在方法声明处。</span></span><br><span class="line"><span class="comment">*       2. throws关键字后面声明的异常必须是Exception或者Exception的子类。</span></span><br><span class="line"><span class="comment">*       3. 方法内部如果抛出了多个异常对象，那么throws后面必须也声明多个异常。</span></span><br><span class="line"><span class="comment">*           如果抛出的多个异常有父子类关系，那么直接声明父类异常即可。</span></span><br><span class="line"><span class="comment">*       4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常。</span></span><br><span class="line"><span class="comment">*           要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM。</span></span><br><span class="line"><span class="comment">*           要么try...catch自己处理异常。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Throws</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果抛出的多个异常有父子类关系，那么直接声明父类异常即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        readFile(<span class="string">&quot;c:\\a.tx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   定义一个方法，用于判断读取文件路径是否正确。</span></span><br><span class="line"><span class="comment">    *   如果路径不正确，抛出文件找不到异常对象，告知方法的调用者。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!filename.equals(<span class="string">&quot;c:\\a.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件路径找不到！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   如果传递的路径，不是.txt结尾</span></span><br><span class="line"><span class="comment">        *   抛出IO异常，告知方法的调用者。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span>(!filename.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;文件后缀名不对！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;路径正确！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="异常捕获try…catch"><a href="#异常捕获try…catch" class="headerlink" title="异常捕获try…catch"></a>异常捕获try…catch</h4><p>概念：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   try...catch:异常处理的第二种方式，自己处理。</span></span><br><span class="line"><span class="comment">*   格式：</span></span><br><span class="line"><span class="comment">*       try&#123;</span></span><br><span class="line"><span class="comment">*           可能产生异常的代码</span></span><br><span class="line"><span class="comment">*       &#125; catch (定义一个异常变量，用来接收try中抛出的异常对象)&#123;</span></span><br><span class="line"><span class="comment">*               异常的处理逻辑。</span></span><br><span class="line"><span class="comment">*               一般会将异常的信息记录到一个日志中。</span></span><br><span class="line"><span class="comment">*           &#125;</span></span><br><span class="line"><span class="comment">*        ...</span></span><br><span class="line"><span class="comment">*          catch(异常类名 变量名)&#123;</span></span><br><span class="line"><span class="comment">*           &#125;</span></span><br><span class="line"><span class="comment">*   注意：</span></span><br><span class="line"><span class="comment">*       1. try中可能抛出多个异常对象，那么就可以使用多个catch来处理这些异常变量。</span></span><br><span class="line"><span class="comment">*       2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try...catch之后的代码。</span></span><br><span class="line"><span class="comment">*           如果try中没有产生异常，就不会执行catch中异常处理的内容，执行完try中的代码，继续执行try...catch之后的代码。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04TryCatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            readFile(<span class="string">&quot;c:\\a.tx&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传递的路径有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;后续代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!filename.equals(<span class="string">&quot;c:\\a.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件路径找不到！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *   如果传递的路径，不是.txt结尾</span></span><br><span class="line"><span class="comment">         *   抛出IO异常，告知方法的调用者。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">if</span>(!filename.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;文件后缀名不对！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;路径正确！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>一些特定的代码无论异常是否发生，都需要执行。</p><p>异常会导致程序跳转，导致有些语句执行不到，finally就是解决这个问题。</p><p>finally代码块中存放的代码是一定会被执行的。</p><p>finally一般用于资源释放，无论程序是否出现异常，代码都需要释放。</p><hr><h4 id="多个异常处理"><a href="#多个异常处理" class="headerlink" title="多个异常处理"></a>多个异常处理</h4><p>一个try多个catch注意事项：</p><ol><li><p>多个异常分别处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个异常一次捕获，多次处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">catch</span>&#123;&#125;    </span><br></pre></td></tr></table></figure><p>catch里边定义的异常变量，如果有子父类关系，那么子类的异常变量必须写在上面，否则会报错。</p></li><li><p>多个异常一次捕获一次处理。</p></li></ol><hr><h4 id="子父类异常"><a href="#子父类异常" class="headerlink" title="子父类异常"></a>子父类异常</h4><p>父类异常什么样，子类异常就什么样。</p><hr><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>java提供的异常类不够使用时，需要自己定义一些异常类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxException</span> <span class="keyword">extends</span> <span class="title">Exception</span> / <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 一个空参数的构造方法</span></span><br><span class="line">    <span class="comment">// 2 一个带异常信息的构造方法</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>自定义异常一般都是Exception结尾，说明该类是一个异常类。</p></li><li><p>自定义异常类，必须是继承Exception或者RuntimeException</p><p>继承Exception：自定义的异常类就是一个编译期异常，如果该方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch。</p><p>继承RuntimeException：自定义的异常类就是一个运行期异常，无需处理，交给JVM(中断处理)。</p></li></ol><hr>]]></content>
    
    
    <summary type="html">Java中异常知识点。(throw,throws,try...catch...)</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/02】15_Java_Map</title>
    <link href="http://example.com/2021/12/18/15_Map/"/>
    <id>http://example.com/2021/12/18/15_Map/</id>
    <published>2021-12-18T12:46:49.109Z</published>
    <updated>2021-12-18T13:08:05.225Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map&lt;K,V&gt;：将键映射到值。</p><p><strong>特点：</strong></p><ol><li>键唯一。</li><li>键和值一一对应。一个键对应一个值。</li><li>靠键维护他们的关系。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   java.util.Map&lt;k,v&gt;集合</span></span><br><span class="line"><span class="comment">*   Map集合的特点:</span></span><br><span class="line"><span class="comment">*       1. Map集合是一个双列集合，一个元素包含两个值(一个key,一个value)</span></span><br><span class="line"><span class="comment">*       2. Map集合中的元素，key和value的数据类型可以是相同，也可以是不同。</span></span><br><span class="line"><span class="comment">*       3. Map集合中的元素，key不允许重复，value是可以重复的。</span></span><br><span class="line"><span class="comment">*       4. Map集合中的元素，key和value是一一对应的。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h4><p>(1) 第一种方式，通过键找值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Map集合的第一种遍历的方式：通过键找值的方式。</span></span><br><span class="line"><span class="comment">*   Map集合中的方法：</span></span><br><span class="line"><span class="comment">*       Set&lt;K&gt; keySet() 返回此映射中包含的键的Set视图。</span></span><br><span class="line"><span class="comment">*   实现步骤：</span></span><br><span class="line"><span class="comment">*       1. 使用Map集合中的方法keySet(),把Map集合所有的key取出来，存储到一个Set集合中。</span></span><br><span class="line"><span class="comment">*       2. 遍历set集合，获取Map集合中的每一个key。</span></span><br><span class="line"><span class="comment">*       3. 通过Map集合中的方法get(key),通过key找到value。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p>(2) 第二种方式，通过Entry对象，查找键和值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Map.Entry&lt;K,V&gt;:在Map接口中有一个内部接口Entry</span></span><br><span class="line"><span class="comment">*   作用: 当Map集合一创建，就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值的映射关系)。</span></span><br><span class="line"><span class="comment">*   Map集合遍历的第二种方式：使用Entry对象遍历。</span></span><br><span class="line"><span class="comment">*   Map集合中的方法：</span></span><br><span class="line"><span class="comment">*       Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><hr><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap**&lt;**K,V&gt; implement Map&lt;k,v&gt;</p><p>特点：</p><ol><li><p>底层是哈希表，查询速度非常快。</p><p>JDK1.8之前：数组+单向链表。</p><p>JDK1.8之后：数组+单向链表/红黑树：提高查询的速度。</p></li><li><p>一个无序的集合。存储元素和取出元素的顺序有可能不一致。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo03_Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   HashMap存储自定义类型键值</span></span><br><span class="line"><span class="comment">*   Map集合保证key是唯一的：</span></span><br><span class="line"><span class="comment">*       作为key的元素，必须重写hashCode方法和equals方法，保证key唯一。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04HashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用keySet和增强for遍历集合</span></span><br><span class="line">        show00();</span><br><span class="line">        <span class="comment">// 使用entrySet和增强for循环遍历Map集合</span></span><br><span class="line"><span class="comment">//        show01();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show00</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashMap集合</span></span><br><span class="line">        HashMap&lt;String,Person&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 往集合添加元素</span></span><br><span class="line">        map.put(<span class="string">&quot;英国&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;俄罗斯&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;普京&quot;</span>,<span class="number">30</span>));</span><br><span class="line">        map.put(<span class="string">&quot;精灵国&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        map.put(<span class="string">&quot;秦国&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;秦始皇&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        <span class="comment">// 使用keySet和增强for遍历集合</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            Person value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *   HashMap存储自定义类型的键值。</span></span><br><span class="line"><span class="comment">     *   Key:Person类型</span></span><br><span class="line"><span class="comment">     *       Person类型就必须重写hashCode方法和equals方法，保证key唯一。</span></span><br><span class="line"><span class="comment">     *   Value:String类型</span></span><br><span class="line"><span class="comment">     *       可以重复。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建HashMap集合</span></span><br><span class="line">        HashMap&lt;Person,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 往集合添加元素</span></span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>),<span class="string">&quot;英国&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;普京&quot;</span>,<span class="number">30</span>),<span class="string">&quot;俄罗斯&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;女王&quot;</span>,<span class="number">18</span>),<span class="string">&quot;精灵国&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;秦始皇&quot;</span>,<span class="number">17</span>),<span class="string">&quot;秦国&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用entrySet和增强for循环遍历Map集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Person,String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Person,String&gt; entry:set) &#123;</span><br><span class="line">            Person key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;集合</p><p>特点：</p><ol><li>底层是哈希表+链表（保证了迭代的顺序）</li><li>是一个有序的集合，存储元素与取出元素的顺序是一致的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fanpeng.day06.Demo03_Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Map接口的哈希表和链表的实现，具有可预知的迭代顺序。</span></span><br><span class="line"><span class="comment">*   底层原理：</span></span><br><span class="line"><span class="comment">*       哈希表+链表（记录链表的顺序）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05LinkedHashMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用普通的HashMap</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(<span class="string">&quot;__________________________&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用LinkedHashMap,保证顺序</span></span><br><span class="line">        LinkedHashMap&lt;String,String&gt; map1 = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        map1.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123;a=d, b=b, c=c&#125;</span><br><span class="line">__________________________</span><br><span class="line">&#123;a=d, c=c, b=b&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ol><li><p>此类实现一个哈希表，该哈希表将键映射到相应的值，任何<strong>非null对象</strong>都可以用作键或者值。</p></li><li><p>被HashMap取代了。</p></li><li><p>Hashtable的Properties依旧使用。常用于IO流操作。</p></li></ol><hr><h3 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h3><p>List接口、Set接口、Map接口：增加一个静态的方法of,可以给集合一次性添加多个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">list&lt;E&gt; <span class="title">of</span> <span class="params">(E... elements)</span></span>;</span><br></pre></td></tr></table></figure><p>使用前提：</p><ol><li>当集合中存储的元素的个数已经确定了，不在改变时使用。</li></ol><p>注意：</p><ol><li>of方法只适用于List接口，Set接口，Map接口，不适用于接口的实现类。</li><li>of方法的返回值是一个不可改变的集合，集合<strong>不再使用add，put方法</strong>添加元素，会抛出异常。</li><li>Set接口和Map接口在调用of方法的时候，<strong>不能有重复的元素</strong>，否则会抛出异常。</li></ol><hr>]]></content>
    
    
    <summary type="html">Java中Map接口知识点。(HashMap,LinkedHashMap,Hashtable)</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/01】14_Java_可变参数</title>
    <link href="http://example.com/2021/12/18/14_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>http://example.com/2021/12/18/14_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</id>
    <published>2021-12-18T12:45:23.085Z</published>
    <updated>2021-12-18T13:04:49.826Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   使用前提：当方法的参数列表数据类型已经确定，参数的个数不能确定，就可以使用可变参数。</span></span><br><span class="line"><span class="comment">*   使用格式：</span></span><br><span class="line"><span class="comment">*           修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;</span></span><br><span class="line"><span class="comment">*   可变参数的原理：</span></span><br><span class="line"><span class="comment">*           可变参数底层就是一个数组，根据传递参数的个数不同，会创建不同长度的数组，来存储这些参数。</span></span><br><span class="line"><span class="comment">*           传递的参数的个数，可以是0，1，2...多个</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01VarArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个累加变量，记录求和。</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历数组中的每一个元素。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>一个方法的参数列表，只能有一个可变参数。</li><li>如果方法的参数有多个，那么可变参数必须放在参数列表的末尾。</li></ol><hr>]]></content>
    
    
    <summary type="html">Java中可变参数知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/12/01】13_Java_List知识点</title>
    <link href="http://example.com/2021/12/18/13_List/"/>
    <id>http://example.com/2021/12/18/13_List/</id>
    <published>2021-12-18T12:39:17.826Z</published>
    <updated>2021-12-18T12:45:07.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><p>List接口的特点：</p><ol><li>有序的集合，存储元素与取出元素的顺序是一致的。</li><li>有索引，包含了一些带索引的方法。</li><li>允许存储重复的元素。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.list接口 extends Collection接口;</span><br></pre></td></tr></table></figure><h3 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ArrayList;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>ArrayList集合数据存储的结构是<strong>数组结构</strong>。元素增删慢，查找快。</li><li>由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</li></ol><h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>底层是一个链表结构，查询慢，增删快。</li><li>里面包含了大量操作首尾元素的方法。</li><li>使用LinkedList集合特有的方法，<strong>不能使用多态</strong>。</li></ol><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>继承Collection类。</p><p>特点：</p><ol><li>不包含重复元素。</li><li>没有索引。</li></ol><h4 id="HashSet集合-implements-Set接口"><a href="#HashSet集合-implements-Set接口" class="headerlink" title="HashSet集合 implements Set接口"></a>HashSet集合 implements Set接口</h4><p>特点：</p><ol><li>不允许存储重复的元素。</li><li>没有索引，没有带索引的方法。不能使用for循环遍历。</li><li>无序的集合，存储元素和取出元素的顺序不一致。</li><li>底层是一个哈希表结构(查询速度非常快)。</li></ol><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><p>一个十进制的整数，由系统随机给出。（对象的地址，是一个逻辑地址，不是实际的存储的物理地址。）</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>HashSet集合存储的数据的结构。(哈希表)</p><p>JDK1.8之前：哈希表= 数组 + 链表。</p><p>JDK1.8之后：哈希表 = 数组 + 链表；哈希表 = 数组 + 红黑树(提升查询的速度)。</p><p><strong>哈希表的特点：速度快。</strong></p><p><strong>使用HashSet存储自定义类型的元素。</strong></p><p>必须重写hashCode()方法和equals方法。</p><h4 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h4><p>继承自 HashSet集合。</p><p>特点：</p><ol><li>底层是一个<strong>哈希表</strong>(数组+链表/红黑树)+<strong>链表</strong>：多一条链表（记录元素的存储位置），保证元素有序。</li><li>不允许重复。</li></ol>]]></content>
    
    
    <summary type="html">Java中List集合相关内容。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/30】12_Java_数据结构基础知识点(一)</title>
    <link href="http://example.com/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2021/12/18/12_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-12-18T12:31:04.494Z</published>
    <updated>2021-12-18T12:34:16.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1 栈"></a>1 栈</h3><p>特点：先进后出。</p><p>存储元素到集合：入栈、压栈。</p><p>取出集合中的元素：出栈。</p><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2 队列"></a>2 队列</h3><p>特点：先进先出。</p><p>入口和出口在集合的两侧。</p><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h3><p>特点：查询快，增删慢。</p><p>查询快：数组的地址是连续的，根据数组的首地址可以找到数组，通过数组的索引可以快速查找某一个元素。</p><p>增删慢：数组的长度是固定的，要增加或删除一个元素，必须创建一个新数组，把源数组的数据复制过来。</p><h3 id="4-链表"><a href="#4-链表" class="headerlink" title="4 链表"></a>4 链表</h3><p>特点：查询慢，增删快。</p><p>查询慢：链表中的地址不是连续的，每次查询元素，都必须从头开始查询。</p><p>增删快：链表结构，增加删除一个元素，对链表的整体结构没有影响，所以增删快。</p><p>单向链表：链表中只有一条链子，不能保证元素的顺序（存储元素和取出元素的顺序有可能不一致）</p><p>双向链表：链表中有两条链，一条专门记录元素的顺序，是一个有序的集合。</p><h3 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5 红黑树"></a>5 红黑树</h3><p>二叉树：分支不能超过两个。</p><p>排序树：在二叉树的基础上，元素有大小顺序。左子树小，右子树大。</p><p>平衡树：左子树与右子树相等。</p><p><strong>红黑树：</strong>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数与最小次数不能超过2倍。</p>]]></content>
    
    
    <summary type="html">数据结构中栈、队列、数组、链表、红黑树。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/30】11_Java_泛型</title>
    <link href="http://example.com/2021/12/17/11_%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2021/12/17/11_%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-12-17T14:08:21.494Z</published>
    <updated>2021-12-17T14:12:37.132Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1 泛型"></a>1 泛型</h3><p>一种不确定的数据类型，不知道使用什么数据类型的时候可以使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中&lt;E&gt;代表泛型，不知道使用什么数据类型。</span></span><br></pre></td></tr></table></figure><p>创建对象的时候，就会确定泛型的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会把数据类型当作参数传递，下列例子就是将String赋值给泛型E。</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2 Student类型的数据</span></span><br><span class="line">ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="2-创建集合对象，使用泛型"><a href="#2-创建集合对象，使用泛型" class="headerlink" title="2 创建集合对象，使用泛型"></a>2 创建集合对象，使用泛型</h3><p>好处：</p><ol><li>避免了类型转换的麻烦，存储的什么类型，取出的就是什么类型。</li><li>把运行期异常（代码运行之后抛出的异常），提升到编译器（写代码报错）。</li></ol><p>弊端：</p><ol><li>泛型是什么类型，就只能存储什么类型的数据。</li></ol><h4 id="定义含有泛型的类"><a href="#定义含有泛型的类" class="headerlink" title="定义含有泛型的类"></a>定义含有泛型的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式</span></span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;泛型&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用例子</span></span><br><span class="line">GenericClass&lt;Integer&gt; gc1 = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">gc1.setName(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Integer name = gc1.getName();</span><br><span class="line">System.out.println(name); </span><br></pre></td></tr></table></figure><h4 id="定义含有泛型的方法"><a href="#定义含有泛型的方法" class="headerlink" title="定义含有泛型的方法"></a>定义含有泛型的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式</span></span><br><span class="line">修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>含有泛型的方法，在调用的时候确定泛型的数据类型。</p><p>传递什么类型的数据，泛型就是什么类型。</p><h4 id="定义含有泛型的接口"><a href="#定义含有泛型的接口" class="headerlink" title="定义含有泛型的接口"></a>定义含有泛型的接口</h4><p>接口使用什么泛型，实现类就使用什么泛型，类跟着接口走。</p><p>相当于定义了一个含有泛型的类，创建对象的时候确定泛型的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterfaceImpl</span>&lt;<span class="title">I</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">publuc <span class="keyword">void</span> <span class="title">method</span><span class="params">(I i)</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-泛型通配符"><a href="#3-泛型通配符" class="headerlink" title="3 泛型通配符"></a>3 泛型通配符</h3><p>当使用泛型类或接口的时候，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用通配符后，只能使用Object类中的共性方法，集合中元素自身的方法不可用。</p><p>泛型的通配符：不知道使用什么类型来接受的时候，此时可以使用?,?表示未知通配符。</p><p>此时只能接收数据，不可以往该集合中存储数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">泛型的通配符：</span></span><br><span class="line"><span class="comment">？：代表任意的数据类型</span></span><br><span class="line"><span class="comment">使用方式：</span></span><br><span class="line"><span class="comment">不能创建对象使用。</span></span><br><span class="line"><span class="comment">只能作为方法的参数使用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="泛型通配符的高阶使用"><a href="#泛型通配符的高阶使用" class="headerlink" title="泛型通配符的高阶使用"></a>泛型通配符的高阶使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">泛型的上限限定：? extends E 代表使用的泛型只能是E类型的子类/本身</span></span><br><span class="line"><span class="comment">泛型的下限限定：? super E 代表使用的泛型只能是E类型的父类/本身</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">Java中泛型的知识点。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】10_Java_Collection集合</title>
    <link href="http://example.com/2021/12/17/10_Collection/"/>
    <id>http://example.com/2021/12/17/10_Collection/</id>
    <published>2021-12-17T14:05:58.300Z</published>
    <updated>2021-12-18T12:30:36.892Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h2><p>Collection内存储<strong>对象的集合</strong>。</p><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h3><p>用于迭代访问Collection中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 获取集合对应的迭代器，用来遍历集合中的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 判断集合中还有没有下一个元素，有就返回true,没有就返回false</span></span><br><span class="line">next(); <span class="comment">// 返回迭代的下一个元素</span></span><br></pre></td></tr></table></figure><p>Iterator迭代器是一个接口，无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方法。</p><p>Collection接口中有一个方法，叫iterator()，这个方法返回迭代器的实现类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 返回在此collection的元素上进行迭代的迭代器。</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的使用【重点】"><a href="#迭代器的使用【重点】" class="headerlink" title="迭代器的使用【重点】"></a>迭代器的使用【重点】</h4><ol><li>使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收(多态)</li><li>使用Iterator接口中的方法hasNext判断还有没有下一个元素</li><li>使用Iterator接口中的方法next取出集合中的下一个元素</li></ol><h2 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h2><hr>]]></content>
    
    
    <summary type="html">Java中Collection集合的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】9_Java_包装类</title>
    <link href="http://example.com/2021/12/17/9_%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>http://example.com/2021/12/17/9_%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2021-12-17T14:03:39.288Z</published>
    <updated>2021-12-17T14:05:40.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>基本数据类型,使用起来非常方便,但是没有对应的方法来操作这些基本类型的数据。</p><p>可以使用一个类,把基本类型的数据装起来,在类中定义一些方法,这个类叫做包装类。</p><p>我们可以使用类中的方法来操作这些基本类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装箱：把基本类型的数据，包装到包装类中（基本数据类型-&gt;包装类）</span></span><br><span class="line"><span class="comment">* 构造方法：</span></span><br><span class="line"><span class="comment">*   Integer(int value) 构造一个新的Integer对象，代表指定的int值。</span></span><br><span class="line"><span class="comment">*   Integer(String s) 构造一个新分配的Integer对象，表示String参数所指示的int值。</span></span><br><span class="line"><span class="comment">*   传递的字符串必须是基本类型的字符串，否则会抛出异常。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(in1);</span><br><span class="line"></span><br><span class="line">Integer in2 = <span class="keyword">new</span> Integer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(in2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 拆箱：在包装类中取出基本类型的数据。（包装类-&gt;基本类型的数据）</span></span><br><span class="line"><span class="comment">* 成员方法：</span></span><br><span class="line"><span class="comment">*   int intValue()以int类型返回该Integer的值。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h4 id="基本类型与字符串类型的相互转换"><a href="#基本类型与字符串类型的相互转换" class="headerlink" title="基本类型与字符串类型的相互转换"></a>基本类型与字符串类型的相互转换</h4><p><strong>(1) 基本类型到字符串类型</strong></p><ol><li>基本类型的值+“ ” 【最简单的方法】。</li><li>包装类的静态方法toString(参数)，不是Object中的toString()重载。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 返回一个表示指定整数的String对象。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>String类的静态方法valueOf(参数)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 返回int参数的字符串表示形式。</span></span><br></pre></td></tr></table></figure><p><strong>(2) 字符串到基本类型</strong></p><p>使用包装类的静态方法parseXXX(“字符串”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="comment">// Double类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">parseDouble</span><span class="params">(String s)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中包装类的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>【21/11/29】8_Java_StringBuilder类</title>
    <link href="http://example.com/2021/12/17/8_StringBuilder/"/>
    <id>http://example.com/2021/12/17/8_StringBuilder/</id>
    <published>2021-12-17T14:02:26.464Z</published>
    <updated>2021-12-17T14:03:28.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="StringBuilder类【字符串缓冲区】"><a href="#StringBuilder类【字符串缓冲区】" class="headerlink" title="StringBuilder类【字符串缓冲区】"></a>StringBuilder类【字符串缓冲区】</h3><p>可以解决字符串拼接问题。</p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><ol><li>字符串是常量，被定义后不能被改变。</li><li>字符串的底层是一个被final修饰的数组，不能改变，是一个常量。</li></ol><p>使用String进行字符串的相加，内存会有多个字符串，占用空间较多，效率低下。</p><h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><ol><li><p>是一个字符串缓冲区，提高字符串操作的效率。</p></li><li><p>底层是一个数组，但是<font color=red>没有被final修饰</font>，可以改变。</p></li><li><p>在内存中始终是一个数组，占用空间少，效率高。超出了StringBuilder的容量，会自动扩容。</p></li></ol><p><strong>1 构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 构造一个不带字符的字符串生成器，其容量为16个字符。</span></span><br><span class="line">StringBuilder bu1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 2 构造一个字符串生成器，并初始化为指定的字符串内容。</span></span><br><span class="line">StringBuilder(String str);</span><br></pre></td></tr></table></figure><p><strong>2 成员方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 添加任意类型数据的字符串形式，并返回当前对象自身。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="comment">// 2 将当前的StringBuilder对象转换为String对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java中StringBuilder的相关操作。</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
